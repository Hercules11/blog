<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>可以取消的网络请求 promise 实现</title>
    <link href="/blog/2025/03/04/%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%20promise%20%E5%AE%9E%E7%8E%B0/"/>
    <url>/blog/2025/03/04/%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%20promise%20%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在某些时候，比如进入软件 viewers 选中一个 病人的序列，但是想看另一个序列，此时首先选中的序列已经在加载中，而想看的序列却被排序在后面才能被加载，这时候我们需要一个可取消的网络请求 promise 实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImage</span>(<span class="hljs-params">imageId</span>) &#123;<br>    <span class="hljs-comment">// Parse the imageId and return a usable URL (logic omitted)</span><br>    <span class="hljs-keyword">const</span> url = <span class="hljs-title function_">parseImageId</span>(imageId);<br>    <br>    <span class="hljs-keyword">let</span> oReq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); <span class="hljs-comment">// Store the request so we can abort it later</span><br><br>    <span class="hljs-comment">// Create a new Promise</span><br>    <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        oReq.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>        oReq.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;arraybuffer&quot;</span>;<br><br>        oReq.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (oReq.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span> (oReq.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-comment">// Request succeeded, Create an image object (logic omitted)</span><br>                    <span class="hljs-keyword">const</span> image = <span class="hljs-title function_">createImageObject</span>(oReq.<span class="hljs-property">response</span>);<br>                    <span class="hljs-title function_">resolve</span>(image);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Handle error scenarios</span><br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(oReq.<span class="hljs-property">statusText</span>));<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        oReq.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Network Error&quot;</span>));<br>        &#125;;<br><br>        oReq.<span class="hljs-property">onabort</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Request Aborted&quot;</span>));<br>        &#125;;<br><br>        oReq.<span class="hljs-title function_">send</span>();<br>    &#125;);<br><br>    <span class="hljs-comment">// Define the cancel function to abort the request</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">cancelFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (oReq) &#123;<br>            oReq.<span class="hljs-title function_">abort</span>(); <span class="hljs-comment">// Cancel the request</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// Return both the promise and the cancel function</span><br>    <span class="hljs-keyword">return</span> &#123; promise, cancelFn &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>简而言之就是利用 XMLHttpRequest 请求的 onabort 方法，通过 cancelFn 调用，在需要的时候执行 cancelFn</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调试react源代码的步骤</title>
    <link href="/blog/2025/01/28/%E8%B0%83%E8%AF%95react%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
    <url>/blog/2025/01/28/%E8%B0%83%E8%AF%95react%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7126501202866470949">全网最优雅的 React 源码调试方式</a></p><p>被教程坑了一把，react 在 19 版本以后就删除了 umd 的构建方式，导致原作者文章中提供的方法失效了。</p><p>具体表现为，在将 react 和 react-dom 替换为外部引用（即包含react编译后的源代码到react源代码的映射的map文件）的时候，文件系统不支持 cjs 类型的模块引用。本身项目是由 webpack 打包起来的，但是当作者将 react 和 react-dom 脱离 webpack 的管辖时，原有的模块系统也失效了。umd 本身是自包含的，可以不借助打包工具直接引入到浏览器中使用。</p><p>当我在想，是回退到作者演示的版本去搭建测试环境，还是想办法解决现有的模块引用问题的时候，我了问 chatgpt, 如何进行测试项目中的 react 源代码调试？</p><p>结果，chatgpt 告诉我可以用 yarn link，生成源文件模块的引用，再到测试项目中进行 yarn link [package name]。</p><p>于是乎，我用了 chatgpt 提示的方法，成功运行起了测试环境，也可以链接到 react 源代码进行调试。我发现和原作者讲的有一些不同，原作者认为 react 源代码编译到 单个文件 加 单个文件.map.js 的形式，再通过 webpack 打包到 bundle.js 到运行到浏览器中，调试工具不能触及 react 源代码。因为调试工具只解析一次 sourceMap。我实际测试发现，可以正常调试 react 源代码，调试工具会定位原文件的位置。</p><p><img src="/blog/images/2025-01-29-025642.png" alt="2025-01-29-025642"></p>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react 整体架构</title>
    <link href="/blog/2025/01/23/react%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <url>/blog/2025/01/23/react%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>要理解一个技术，首先要知道一个前提，技术是用来解决问题的。那么，对于 react，这个前端领域最流行的技术框架之一，它要解决的问题是什么？</p><p>问题就是，传统的前端网页开发的效率很低。无论是 html 标签、 css 样式编写，还是 js 代码对相关元素的操作，尤其是在项目规模越来越大的情况下，项目的开发维护都是个大问题。那为什么 react 出现之前没有面临代码规模大的问题——因为 v8 引擎出现之前，大量js 代码的运行效率用户接受不了，也就谈不上有相关需求。v8 出现以后，使得规模大的代码运行效率变得可以接受后，解决大规模代码的项目才有价值。</p><p>react 分别从多个角度对前端开发进行了抽象，提高效率。因为频繁利用浏览器的 dom 操作接口效率低，所以引入虚拟 DOM，将对 dom 元素的操作转变为对虚拟 DOM 的操作。将 html 的编写转化为使用特定的 jsx 语法，以便进行更好地与 js 逻辑融合。将网页应用拆分成模块，引入组件化开发，降低心智负担。</p><p>引入了新的解决方案，那么也会出现一些问题要解决。比如组件的数据如何在组件树上进行共享？特定元素触发的事件如何传导到组件树指定的位置？以及数据的响应式特性，如何在组件树上实现跟随式的数据变化？</p><p>针对这些问题，react的开发者们给出了具体的代码。当然不是每一行代码都要自己想，很多子问题的解决方案都是可以复用的，比如 jsx 的解析语法啥的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>passive的语义和它的作用之间的关联</title>
    <link href="/blog/2025/01/22/passive%E7%9A%84%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94/"/>
    <url>/blog/2025/01/22/passive%E7%9A%84%E8%AF%AD%E4%B9%89%E5%92%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94/</url>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/2025-01-22-235400.png" alt="passive"></p><h3 id="从语义角度解释-passive"><a href="#从语义角度解释-passive" class="headerlink" title="从语义角度解释 passive"></a><strong>从语义角度解释 <code>passive</code></strong></h3><p><strong><code>passive</code></strong> 的字面意思是 <strong>“被动的”</strong> 或 <strong>“不主动干预的”</strong>。在事件监听器中，<code>passive</code> 的含义与它的语义高度契合，具体体现为：</p><hr><h3 id="1-被动的监听器"><a href="#1-被动的监听器" class="headerlink" title="1. 被动的监听器"></a><strong>1. 被动的监听器</strong></h3><ul><li><strong>默认行为</strong>：浏览器在触发某些事件（如 <code>touchmove</code>、<code>scroll</code>）时会等待事件监听器执行完成，以检查是否调用了 <code>preventDefault()</code> 来阻止默认行为。</li><li><strong><code>passive: true</code></strong> 的含义：声明监听器是“被动的”，即它不会主动干预或阻止事件的默认行为，浏览器可以直接处理默认行为（如页面滚动）而无需等待。</li></ul><p>这样，<code>passive</code> 的语义表现为一种“不干涉”的行为。</p><hr><h3 id="2-对比主动干预（non-passive）"><a href="#2-对比主动干预（non-passive）" class="headerlink" title="2. 对比主动干预（non-passive）"></a><strong>2. 对比主动干预（non-passive）</strong></h3><p>如果没有 <code>passive: true</code>，监听器可能会变成“主动干预者”，即通过调用 <code>preventDefault()</code> 改变事件的默认执行逻辑。此时，浏览器不得不等待监听器执行完，确定是否阻止默认行为。</p><ul><li><strong>主动监听器（非 <code>passive</code>）</strong>：监听器会干预默认行为，例如阻止滚动。</li><li><strong>被动监听器（<code>passive</code>）</strong>：监听器不干预默认行为，例如允许滚动正常发生。</li></ul><hr><h3 id="3-语义的核心：不干预默认行为"><a href="#3-语义的核心：不干预默认行为" class="headerlink" title="3. 语义的核心：不干预默认行为"></a><strong>3. 语义的核心：不干预默认行为</strong></h3><p><code>passive</code> 的设计初衷就是优化浏览器性能，避免事件监听器主动干预默认行为。因此，从语义上可以将其理解为：</p><ul><li><strong>“我只是观察事件，不会主动插手。”</strong></li><li><strong>“浏览器可以自由地处理事件的默认行为。”</strong></li></ul><p>这与 “被动” 的定义一致，即仅观察而不采取干预措施。</p><hr><h3 id="4-实际案例中的语义体现"><a href="#4-实际案例中的语义体现" class="headerlink" title="4. 实际案例中的语义体现"></a><strong>4. 实际案例中的语义体现</strong></h3><h4 id="没有-passive（默认情况下）"><a href="#没有-passive（默认情况下）" class="headerlink" title="没有 passive（默认情况下）"></a><strong>没有 <code>passive</code>（默认情况下）</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 明确阻止默认行为（滚动）。</span><br>&#125;, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br></code></pre></td></tr></table></figure><p>这里监听器是“主动的”，会干预触摸事件并阻止页面滚动。</p><h4 id="设置-passive-true"><a href="#设置-passive-true" class="headerlink" title="设置 passive: true"></a><strong>设置 <code>passive: true</code></strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// 不会调用 preventDefault()，只观察，不干预。</span><br>&#125;, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><p>这里监听器是“被动的”，不干预触摸事件的默认行为，页面滚动可以正常发生。</p><hr><h3 id="5-总结：语义与作用的契合"><a href="#5-总结：语义与作用的契合" class="headerlink" title="5. 总结：语义与作用的契合"></a><strong>5. 总结：语义与作用的契合</strong></h3><ul><li><p><strong><code>passive</code> 的语义</strong>：表示监听器仅处于“被动观察”的状态，不会主动干预事件的默认行为。</p></li><li><p>现实中的类比</p><p>：</p><ul><li>一个“主动”参与的观察者可能会插手正在发生的事情。</li><li>一个“被动”的观察者只记录发生的事情，而不试图改变它。</li></ul></li></ul><p><code>passive: true</code> 的设计正是基于这种“不干预”的语义逻辑，同时提升了浏览器的性能表现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术细节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇怪的换行</title>
    <link href="/blog/2024/09/24/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8D%A2%E8%A1%8C/"/>
    <url>/blog/2024/09/24/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8D%A2%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/image-20240924102051222.png" alt="image-20240924102051222"></p><p>在一个 div 元素内部渲染了很多 span 子元素，并且 div 的样式被定义为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">overflow</span>: hidden;<br></code></pre></td></tr></table></figure><p>正常情况下，不在 div 内容区域的元素都会被隐藏。</p><p>但是偶尔有元素，不按预想的方式溢出隐藏，而是直接换行了。</p><p><img src="/blog/images/2024-09-24-102730.png" alt="image-20240924102051222"></p><p>使我百思不得其解。</p><p>问了chatgpt 后，觉得可能是样式没有正常生效。观察了一番，看到了每次换行前的一个元素是包含空格的。类似：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>projector lens<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>（overflow）<br></code></pre></td></tr></table></figure><p>让我想到，可能是没有禁用换行引起的问题。</p><p>随后在父元素上加上了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">white-space</span>: nowrap;<br></code></pre></td></tr></table></figure><p>问题解决。</p><p>至于为什么会出这样的问题——渲染包含空格的 span 后，之后的元素另起一行？</p><p>是什么让渲染器猛然觉得自己要换行来着。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程难题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一条奇怪的 return 语句</title>
    <link href="/blog/2024/09/22/%E4%B8%80%E6%9D%A1%E5%A5%87%E6%80%AA%E7%9A%84%20return%20%E8%AF%AD%E5%8F%A5/"/>
    <url>/blog/2024/09/22/%E4%B8%80%E6%9D%A1%E5%A5%87%E6%80%AA%E7%9A%84%20return%20%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (newVal) &#123;<br>  <span class="hljs-keyword">let</span> size = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> deg = <span class="hljs-number">450</span><br>  <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">332</span>) &#123;<br>      <span class="hljs-built_in">clearInterval</span>(intervalId)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    size += <span class="hljs-number">332</span> / <span class="hljs-number">60</span><br>    deg -= <span class="hljs-number">6</span><br>    <span class="hljs-comment">// 确保 target 是 SVGElement 类型</span><br>    <span class="hljs-keyword">const</span> circle = target.<span class="hljs-property">value</span>.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">SVGElement</span><br>    <span class="hljs-keyword">const</span> dot = target.<span class="hljs-property">value</span>.<span class="hljs-property">children</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">SVGElement</span><br>    <span class="hljs-comment">// 使用 CSSStyleDeclaration 进行类型标注</span><br>    circle.<span class="hljs-property">style</span>.<span class="hljs-property">strokeDashoffset</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;size&#125;</span>px`</span><br>    dot.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;deg&#125;</span>deg)`</span><br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 恢复初始状态</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> // 完成后没有立即执行</span><br>  <span class="hljs-comment">// console.log(&#x27;恢复动画&#x27;)</span><br>  <span class="hljs-comment">// target.value.children[0].style[&#x27;stroke-dashoffset&#x27; as any] = &#x27;0px&#x27;</span><br>  <span class="hljs-comment">// target.value.children[1].style[&#x27;transform&#x27; as any] = &#x27;rotate(450deg)&#x27;</span><br>  <span class="hljs-comment">// 确保 target 是 SVGElement 类型</span><br>  <span class="hljs-keyword">const</span> circle = target.<span class="hljs-property">value</span>.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">SVGElement</span><br>  <span class="hljs-keyword">const</span> dot = target.<span class="hljs-property">value</span>.<span class="hljs-property">children</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">SVGElement</span><br><br>  <span class="hljs-comment">// 使用 CSSStyleDeclaration 进行类型标注</span><br>  circle.<span class="hljs-property">style</span>.<span class="hljs-property">strokeDashoffset</span> = <span class="hljs-string">&#x27;0px&#x27;</span><br>  dot.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;rotate(450deg)&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>清除定时器 Id 后面的 return 语句，是我一开始写的时候没有加上去，导致多跑了一次调度，动画尺寸对不上。而且还出现一个问题，当newVal 值变为 false 时，else 内部的代码，执行了，但是效果没有渲染到页面上，令我百思不得其解。</p><p>我想了好久，决定先解决动画尺寸问题，没想到 else 内部代码不执行的问题也自然而然地解决了。</p><p>问了 chatgpt, 回答如下：</p><blockquote><p><strong>添加 <code>return</code> 的作用</strong>：</p><ul><li>当 <code>size</code> 达到 332 时，<code>clearInterval(intervalId)</code> 停止定时器，<code>return</code> 语句立即退出当前 <code>setInterval</code> 回调函数。</li><li>如果没有 <code>return</code> 语句，即使定时器已被清除，<code>setInterval</code> 的回调函数仍然会继续执行剩下的代码，直到当前执行完毕。</li><li>这种行为可能会导致在 <code>else</code> 分支中（<code>newVal</code> 为 <code>false</code> 的情况下）无法立即执行恢复动画的代码，因为定时器回调函数仍未完全退出，造成异步执行的错乱现象。</li></ul><p><strong>为何 <code>return</code> 使代码运行正常</strong>：</p><ul><li><code>return</code> 语句在定时器回调函数中添加了一个退出点。当满足 <code>size &gt;= 332</code> 的条件时，<code>clearInterval</code> 立即停止定时器的触发，并通过 <code>return</code> 退出当前的回调。</li><li>这避免了回调中残余代码的执行，确保了在 <code>newVal</code> 为 <code>false</code> 时，立即执行 <code>else</code> 分支的逻辑，恢复动画至初始状态。</li></ul></blockquote><p>不是很能说服我，先放这里，以后有机会再来探索</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程难题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS/TS 调试方法总结</title>
    <link href="/blog/2024/07/29/JS%E3%80%81TS%20%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2024/07/29/JS%E3%80%81TS%20%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>对于 <code>js</code> 文件：</p><ul><li>运行命令：<code>node xx.js</code></li><li>调试命令（需要 IDE 的配合， 以 vscode 为例）：<ul><li>开启 <code>ctrl+shift+p</code> 开启 <code>auto attach</code>， 启动程序后自动 attach debugger process 到 nodejs process</li><li>在专门的<code>js debug</code> 控制台运行程序（JavaScript Debug Terminal）</li><li>设置 <code>launch.json</code> 配置，通过侧边栏 debug 功能选择配置启动调试</li></ul></li></ul><p>对于 <code>ts</code> 文件：</p><ul><li>运行命令： <code>tsx xx.ts</code></li><li>调试命令（需要有文件对应的 <code>source map</code> 文件，作为中间层，把 js 代码的执行状态传回 ts 文件）：<ul><li>具体操作为 <code>tsc --sourceMap xx.ts，生成对应的 js 和 map</code> 文件，就直接可以 <code>F5</code>调试了</li><li>使用 <code>tsx</code> <a href="https://tsx.is/vscode#setup">调试文件</a>， </li><li>对于特定的框架，比如 <code>vitest</code> ，内置了相关的支持，查看文档，添加相应的配置即可</li></ul></li></ul><p>坑点（关于<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html"><code>tsconfig.json</code></a>）：</p><ul><li>对于 <code>tsc</code>，不指定文件，则使用当前目录下的 <code>tsconfig.json</code>, 如果指定特定的文件进行编译， 那么不使用当前目录下的 <code>tsconfig.json</code>；（不知道为什么这样设计）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源代码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node 模块系统介绍</title>
    <link href="/blog/2024/07/24/Node%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
    <url>/blog/2024/07/24/Node%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>今天又被模块系统坑了一把，所有来做个总结。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">SynchronousExecution</span> &#123;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br><span class="hljs-keyword">const</span> readlineSync = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;readline-sync&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = readlineSync.<span class="hljs-title function_">question</span>(<span class="hljs-string">&quot;What is your name? &quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">weather</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br><span class="hljs-keyword">const</span> open = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;open&quot;</span>).<span class="hljs-property">default</span>; <span class="hljs-comment">// 需要加个默认</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(open);<br><span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;https://www.weather.com/&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">greet</span>();<br><span class="hljs-title function_">weather</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>先看下面这张图，</p><p><img src="/blog/images/Node-rules.jpg" alt="Node module"></p><p>首先确定当前文件使用的模块系统。</p><p>其次来看 Node 的官方文档，对 CommonJS 和 ES module 的介绍。</p><p>Node.js 把有下面这些特征的文件看作是 <a href="https://nodejs.org/api/modules.html">CommonJS modules</a>：</p><ul><li>有 <code>.mjs</code> 文件拓展名的</li><li>有 <code>.js</code> 文件拓展名，并且最近的父级 <code>package.json</code> 文件包含顶层的字段 <code>type</code>，值为<code>commonjs</code></li><li>详情见文档说明</li></ul><hr><p>ES module 和 CommonJS 的互相操作：</p><p>在 CommonJS 模块内部，可以使用动态 import() 来载入 ES modules，或者使用 require 同步载入 ES modules（前提是开启 –experimental-require-module），module.exports 对象作为 default export。</p><p>在 ES modules 模块内部，可以直接导入 CommonJS 模块。</p><p>ES modules 和 CommonJS 主要区别：</p><ul><li>ES modules 没有 require，exports 和 module.exports</li><li>ES modules 没有 _filename 和 _dirname，取而代之的是 import.meta.filename，和 import.meta.dirname</li><li>ES modules 没有 Addon Loading，替代方案为 module.createRequire() 或 process.dlopen</li><li>ES modules 没有 require.resolve，取而代之的是 import.meta.resolve.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源代码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2 scheduler 源代码分析</title>
    <link href="/blog/2024/07/18/Vue2%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/blog/2024/07/18/Vue2%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>在 Vue2 中，调度器（scheduler） 模块主要负责管理和协调多个 Watcher 的更新。它的作用是在 Vue 应用中高效地处理依赖变化，确保响应式数据变化时，相关的视图能够以优化地形式进行。</p><p>主要作用包括：</p><ol><li>批量更新<ul><li>调度器模块通过将多个 Watcher 的更新操作批量处理，避免在一次事件循环中进行多次 DOM 更新。这减少了不必要地渲染，提高了性能</li></ul></li><li>去重<ul><li>在同一事件循环中，如果一个 Watcher 被多次触发更新，调度器模块会确保整个 Watcher 制备运行一次。这是通过 ID 去重机制实现的。</li></ul></li><li>调度优先级<ul><li>不同类型的 Watcher (如渲染 Watcher 和 计算属性 Watcher) 有不同的优先级。调度器模块通过一个队列管理这些 Watcher，并按照优先级顺序进行更新</li></ul></li><li>延迟执行<ul><li>使用 <code>nextTick</code> 函数将 Watcher 更新推迟到下一个事件循环，这样可以确保所有同步操作完成后，再进行 DOM 更新，避免中间态造成的不必要更新。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push a watcher into the watcher queue.</span><br><span class="hljs-comment"> * Jobs with duplicate IDs will be skipped unless it&#x27;s</span><br><span class="hljs-comment"> * pushed when the queue is being flushed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-params">watcher: Watcher</span>) &#123; <span class="hljs-comment">// 属性更新的时候，需要进行入队，也就是说这个 watcher 资源需要更新了</span><br>  <span class="hljs-keyword">const</span> id = watcher.<span class="hljs-property">id</span><br>  <span class="hljs-keyword">if</span> (has[id] != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 通过 id 去重</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (watcher === <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> &amp;&amp; watcher.<span class="hljs-property">noRecurse</span>) &#123; <br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  has[id] = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">if</span> (!flushing) &#123;<br>    queue.<span class="hljs-title function_">push</span>(watcher) <span class="hljs-comment">// 队列，直接任务入队</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// if already flushing, splice the watcher based on its id</span><br>    <span class="hljs-comment">// if already past its id, it will be run next immediately.</span><br>    <span class="hljs-keyword">let</span> i = queue.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="hljs-property">id</span> &gt; watcher.<span class="hljs-property">id</span>) &#123;<br>      i--<br>    &#125;<br>    queue.<span class="hljs-title function_">splice</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher)<br>  &#125;<br>  <span class="hljs-comment">// queue the flush</span><br>  <span class="hljs-keyword">if</span> (!waiting) &#123;<br>    waiting = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">if</span> (__DEV__ &amp;&amp; !config.<span class="hljs-property">async</span>) &#123;<br>      <span class="hljs-title function_">flushSchedulerQueue</span>() <span class="hljs-comment">// 同步的短化，直接运行</span><br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-title function_">nextTick</span>(flushSchedulerQueue) <span class="hljs-comment">// 异步则延迟到下一个事件循环</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Flush both queues and run the watchers.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSchedulerQueue</span>(<span class="hljs-params"></span>) &#123;<br>  currentFlushTimestamp = <span class="hljs-title function_">getNow</span>()<br>  flushing = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">let</span> watcher, id<br><br>  <span class="hljs-comment">// Sort queue before flush.</span><br>  <span class="hljs-comment">// This ensures that:</span><br>  <span class="hljs-comment">// 1. Components are updated from parent to child. (because parent is always</span><br>  <span class="hljs-comment">//    created before the child)</span><br>  <span class="hljs-comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span><br>  <span class="hljs-comment">//    user watchers are created before the render watcher)</span><br>  <span class="hljs-comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span><br>  <span class="hljs-comment">//    its watchers can be skipped.</span><br>  queue.<span class="hljs-title function_">sort</span>(sortCompareFn)<br><br>  <span class="hljs-comment">// do not cache length because more watchers might be pushed</span><br>  <span class="hljs-comment">// as we run existing watchers</span><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.<span class="hljs-property">length</span>; index++) &#123;<br>    watcher = queue[index]<br>    <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">before</span>) &#123;<br>      watcher.<span class="hljs-title function_">before</span>()<br>    &#125;<br>    id = watcher.<span class="hljs-property">id</span><br>    has[id] = <span class="hljs-literal">null</span><br>    watcher.<span class="hljs-title function_">run</span>()<br>    <span class="hljs-comment">// in dev build, check and stop circular updates.</span><br>    <span class="hljs-keyword">if</span> (__DEV__ &amp;&amp; has[id] != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// ：在开发环境中，检查并防止循环更新。如果观察者的 ID 再次被标记为非空，表示发生了循环更新。</span><br>      circular[id] = (circular[id] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>      <span class="hljs-keyword">if</span> (circular[id] &gt; <span class="hljs-variable constant_">MAX_UPDATE_COUNT</span>) &#123;<br>        <span class="hljs-title function_">warn</span>(<br>          <span class="hljs-string">&#x27;You may have an infinite update loop &#x27;</span> +<br>            (watcher.<span class="hljs-property">user</span><br>              ? <span class="hljs-string">`in watcher with expression &quot;<span class="hljs-subst">$&#123;watcher.expression&#125;</span>&quot;`</span><br>              : <span class="hljs-string">`in a component render function.`</span>),<br>          watcher.<span class="hljs-property">vm</span><br>        )<br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// keep copies of post queues before resetting state</span><br>  <span class="hljs-keyword">const</span> activatedQueue = activatedChildren.<span class="hljs-title function_">slice</span>() <span class="hljs-comment">// 包含所有在本次调度过程中被激活的组件。</span><br>  <span class="hljs-keyword">const</span> updatedQueue = queue.<span class="hljs-title function_">slice</span>() <span class="hljs-comment">// 本次调度中被更新的组件</span><br><br>  <span class="hljs-comment">// 创建副本是为了确保在重置调度器状态之前保留这些队列的当前状态。</span><br>  <span class="hljs-title function_">resetSchedulerState</span>() <span class="hljs-comment">// 重置调度器的状态，包括清空队列、重置相关标志和计数器。</span><br><br>    <span class="hljs-comment">// 确保组件在其激活和更新时执行相应的生命周期钩子。</span><br>  <span class="hljs-comment">// call component updated and activated hooks</span><br>  <span class="hljs-title function_">callActivatedHooks</span>(activatedQueue)<br>  <span class="hljs-title function_">callUpdatedHooks</span>(updatedQueue)<br>  <span class="hljs-title function_">cleanupDeps</span>()<br><br>  <span class="hljs-comment">// devtool hook</span><br>  <span class="hljs-comment">/* istanbul ignore if */</span><br>  <span class="hljs-keyword">if</span> (devtools &amp;&amp; config.<span class="hljs-property">devtools</span>) &#123; <span class="hljs-comment">// 如果启用了开发工具，触发 flush 事件。这允许开发工具在调度队列被清空时做出相应反应。</span><br>    devtools.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;flush&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callHook</span>(<span class="hljs-params"></span><br><span class="hljs-params">  vm: Component,</span><br><span class="hljs-params">  hook: string,</span><br><span class="hljs-params">  args?: any[],</span><br><span class="hljs-params">  setContext = <span class="hljs-literal">true</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// #7573 disable dep collection when invoking lifecycle hooks</span><br>  <span class="hljs-title function_">pushTarget</span>()<br>  <span class="hljs-keyword">const</span> prevInst = currentInstance<br>  <span class="hljs-keyword">const</span> prevScope = <span class="hljs-title function_">getCurrentScope</span>()<br>  setContext &amp;&amp; <span class="hljs-title function_">setCurrentInstance</span>(vm)<br>  <span class="hljs-keyword">const</span> handlers = vm.<span class="hljs-property">$options</span>[hook]<br>  <span class="hljs-keyword">const</span> info = <span class="hljs-string">`<span class="hljs-subst">$&#123;hook&#125;</span> hook`</span><br>  <span class="hljs-keyword">if</span> (handlers) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = handlers.<span class="hljs-property">length</span>; i &lt; j; i++) &#123;<br>      <span class="hljs-title function_">invokeWithErrorHandling</span>(handlers[i], vm, args || <span class="hljs-literal">null</span>, vm, info)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_hasHookEvent</span>) &#123;<br>    vm.$emit(<span class="hljs-string">&#x27;hook:&#x27;</span> + hook)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (setContext) &#123;<br>    <span class="hljs-title function_">setCurrentInstance</span>(prevInst)<br>    prevScope &amp;&amp; prevScope.<span class="hljs-title function_">on</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">popTarget</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>callHook</code> 函数是 Vue.js 框架中一个非常重要的内部函数，用于调用组件实例的生命周期钩子函数。生命周期钩子是 Vue.js 中定义的一系列方法，在组件的不同阶段被自动调用，比如 <code>created</code>、<code>mounted</code>、<code>updated</code>、<code>destroyed</code> 等。</p><h3 id="callHook-函数的实现"><a href="#callHook-函数的实现" class="headerlink" title="callHook 函数的实现"></a><code>callHook</code> 函数的实现</h3><p>下面是 <code>callHook</code> 函数的源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callHook</span>(<span class="hljs-params">vm, hook</span>) &#123;<br>  <span class="hljs-comment">// #7573 disable dep collection when invoking lifecycle hooks</span><br>  <span class="hljs-title function_">pushTarget</span>()<br>  <span class="hljs-keyword">const</span> handlers = vm.<span class="hljs-property">$options</span>[hook]<br>  <span class="hljs-keyword">const</span> info = <span class="hljs-string">`<span class="hljs-subst">$&#123;hook&#125;</span> hook`</span><br>  <span class="hljs-keyword">if</span> (handlers) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = handlers.<span class="hljs-property">length</span>; i &lt; j; i++) &#123;<br>      <span class="hljs-title function_">invokeWithErrorHandling</span>(handlers[i], vm, <span class="hljs-literal">null</span>, vm, info)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_hasHookEvent</span>) &#123;<br>    vm.$emit(<span class="hljs-string">&#x27;hook:&#x27;</span> + hook)<br>  &#125;<br>  <span class="hljs-title function_">popTarget</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-pushTarget"><a href="#1-pushTarget" class="headerlink" title="1. pushTarget()"></a>1. <code>pushTarget()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">pushTarget</span>()<br></code></pre></td></tr></table></figure><ul><li><code>pushTarget()</code>：暂时禁用依赖收集（Dep collection）。<ul><li>Vue.js 使用一个全局的 <code>Dep.target</code> 来跟踪当前正在计算的依赖项。在调用生命周期钩子时，我们不希望收集任何依赖项，因此需要禁用依赖收集。</li></ul></li></ul><h4 id="2-获取生命周期钩子处理函数"><a href="#2-获取生命周期钩子处理函数" class="headerlink" title="2. 获取生命周期钩子处理函数"></a>2. 获取生命周期钩子处理函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> handlers = vm.<span class="hljs-property">$options</span>[hook]<br><span class="hljs-keyword">const</span> info = <span class="hljs-string">`<span class="hljs-subst">$&#123;hook&#125;</span> hook`</span><br></code></pre></td></tr></table></figure><ul><li><code>const handlers = vm.$options[hook]</code>：从组件实例的选项中获取相应的生命周期钩子函数。<ul><li><code>vm.$options</code> 是组件实例的配置对象，包含了所有的生命周期钩子函数。</li><li><code>hook</code> 是钩子函数的名称，比如 <code>created</code>、<code>mounted</code>、<code>updated</code> 等。</li></ul></li><li><code>const info = </code>${hook} hook`：为当前钩子函数调用生成一个描述信息，主要用于错误处理和调试。</li></ul><h4 id="3-调用生命周期钩子函数"><a href="#3-调用生命周期钩子函数" class="headerlink" title="3. 调用生命周期钩子函数"></a>3. 调用生命周期钩子函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (handlers) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = handlers.<span class="hljs-property">length</span>; i &lt; j; i++) &#123;<br>    <span class="hljs-title function_">invokeWithErrorHandling</span>(handlers[i], vm, <span class="hljs-literal">null</span>, vm, info)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>if (handlers)</code>：检查是否存在相应的生命周期钩子函数。</li><li>如果存在，将通过 <code>for</code> 循环遍历并调用每一个钩子函数。<ul><li><code>invokeWithErrorHandling</code>：安全地调用钩子函数，捕获和处理任何错误。<ul><li><code>handlers[i]</code>：当前生命周期钩子函数。</li><li><code>vm</code>：当前组件实例。</li><li><code>null</code>：调用钩子函数时传递的参数（这里没有参数）。</li><li><code>vm</code>：调用钩子函数时的上下文。</li><li><code>info</code>：钩子函数调用的描述信息。</li></ul></li></ul></li></ul><p><code>invokeWithErrorHandling</code> 函数的定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeWithErrorHandling</span>(<span class="hljs-params">handler, context, args, vm, info</span>) &#123;<br>  <span class="hljs-keyword">let</span> res<br>  <span class="hljs-keyword">try</span> &#123;<br>    res = args ? handler.<span class="hljs-title function_">apply</span>(context, args) : handler.<span class="hljs-title function_">call</span>(context)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-title function_">handleError</span>(e, vm, info)<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数通过 <code>try-catch</code> 块调用生命周期钩子函数，以便在出现错误时进行处理。</p><h4 id="4-触发钩子事件"><a href="#4-触发钩子事件" class="headerlink" title="4. 触发钩子事件"></a>4. 触发钩子事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_hasHookEvent</span>) &#123;<br>  vm.$emit(<span class="hljs-string">&#x27;hook:&#x27;</span> + hook)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>if (vm._hasHookEvent)</code>：检查组件实例是否监听了生命周期钩子事件。<ul><li>Vue.js 允许使用事件机制监听生命周期钩子，通过 <code>$emit</code> 触发这些事件。</li></ul></li><li><code>vm.$emit(&#39;hook:&#39; + hook)</code>：触发相应的钩子事件，例如 <code>hook:mounted</code>、<code>hook:updated</code> 等。</li></ul><h4 id="5-popTarget"><a href="#5-popTarget" class="headerlink" title="5. popTarget()"></a>5. <code>popTarget()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">popTarget</span>()<br></code></pre></td></tr></table></figure><ul><li><code>popTarget()</code>：恢复依赖收集状态。<ul><li>在禁用依赖收集后调用，恢复到之前的状态，允许接下来的依赖收集正常进行。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>callHook</code> 函数的主要作用是：</p><ol><li>暂时禁用依赖收集，以确保生命周期钩子调用不会干扰响应式系统。</li><li>从组件实例的选项中获取相应的生命周期钩子函数。</li><li>安全地调用每一个钩子函数，并处理任何可能的错误。</li><li>如果组件实例监听了生命周期钩子事件，触发相应的事件。</li><li>恢复依赖收集状态。</li></ol><p>通过这些步骤，<code>callHook</code> 函数确保了 Vue.js 在组件生命周期的各个阶段能够正确地执行开发者定义的钩子函数，同时维护响应式系统的完整性和稳定性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>源代码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vitest 是如何调试 ts 文件的（chatgpt 回答）</title>
    <link href="/blog/2024/07/12/vitest%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%20ts%20%E6%96%87%E4%BB%B6%E7%9A%84/"/>
    <url>/blog/2024/07/12/vitest%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%20ts%20%E6%96%87%E4%BB%B6%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>问：vitest 是如何调试 ts 文件的</p><p>Vitest 是一个快速的单元测试框架，它可以与 TypeScript 结合使用，并支持对 TypeScript 文件进行调试。Vitest 利用 Vite 的强大功能，自动处理 TypeScript 文件的编译和调试。下面是 Vitest 如何调试 TypeScript 文件的工作原理和相关配置。</p><h3 id="Vitest-如何调试-TypeScript-文件"><a href="#Vitest-如何调试-TypeScript-文件" class="headerlink" title="Vitest 如何调试 TypeScript 文件"></a>Vitest 如何调试 TypeScript 文件</h3><h4 id="1-Vite-的支持"><a href="#1-Vite-的支持" class="headerlink" title="1. Vite 的支持"></a>1. Vite 的支持</h4><p>Vitest 构建在 Vite 之上。Vite 是一个基于 ES 模块的现代前端构建工具，具有快速的冷启动和热更新特性。Vite 内置了对 TypeScript 的支持，通过 esbuild 进行快速编译。因此，Vitest 可以利用 Vite 的 TypeScript 支持来处理和运行 TypeScript 文件。</p><h4 id="2-Source-Maps"><a href="#2-Source-Maps" class="headerlink" title="2. Source Maps"></a>2. Source Maps</h4><p>为了调试 TypeScript 文件，Vitest 使用 source maps。source maps 是一种将编译后的代码映射回源代码的技术，使得调试器可以显示源代码中的行号和文件名。TypeScript 编译器（tsc）和 Vite 都可以生成 source maps，确保在调试时看到的是 TypeScript 源代码，而不是编译后的 JavaScript 代码。</p><h4 id="3-配置-Vitest-和-TypeScript"><a href="#3-配置-Vitest-和-TypeScript" class="headerlink" title="3. 配置 Vitest 和 TypeScript"></a>3. 配置 Vitest 和 TypeScript</h4><p>要使用 Vitest 测试和调试 TypeScript 文件，需要进行一些配置。</p><p><strong>项目结构示例</strong>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">my-project/<br>  ├── node_modules/<br>  ├── <span class="hljs-attribute">src</span>/<br>  │   ├── example<span class="hljs-selector-class">.ts</span><br>  ├── test/<br>  │   ├── example<span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span><br>  ├── package<span class="hljs-selector-class">.json</span><br>  ├── tsconfig<span class="hljs-selector-class">.json</span><br>  └── vite<span class="hljs-selector-class">.config</span>.ts<br></code></pre></td></tr></table></figure><p><strong>package.json</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vitest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test:watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vitest --watch&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;typescript&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.5.4&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;vite&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.7.2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;vitest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^0.0.137&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>tsconfig.json</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ESNext&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ESNext&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;skipLibCheck&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;sourceMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>vite.config.ts</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; configDefaults &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vitest/config&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">test</span>: &#123;<br>    <span class="hljs-comment">// Vitest configuration options</span><br>    <span class="hljs-attr">globals</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">environment</span>: <span class="hljs-string">&#x27;node&#x27;</span>,<br>    <span class="hljs-attr">include</span>: [<span class="hljs-string">&#x27;test/**/*.spec.ts&#x27;</span>],<br>    <span class="hljs-attr">exclude</span>: [...configDefaults.<span class="hljs-property">exclude</span>, <span class="hljs-string">&#x27;test/e2e/*&#x27;</span>]<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>example.spec.ts</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; describe, it, expect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vitest&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; exampleFunction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../src/example&#x27;</span>;<br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;exampleFunction&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;should return the correct value&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">exampleFunction</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;expectedValue&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="调试-TypeScript-文件"><a href="#调试-TypeScript-文件" class="headerlink" title="调试 TypeScript 文件"></a>调试 TypeScript 文件</h3><h4 id="1-在-VS-Code-中配置调试"><a href="#1-在-VS-Code-中配置调试" class="headerlink" title="1. 在 VS Code 中配置调试"></a>1. 在 VS Code 中配置调试</h4><p>为了在 VS Code 中调试 Vitest 测试，需要添加调试配置。</p><p><strong>.vscode/launch.json</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Debug Vitest Tests&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/node_modules/vitest/vitest.mjs&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;run&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;--no-threads&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;autoAttachChildProcesses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;smartStep&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;sourceMaps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;internalConsoleOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;openOnSessionStart&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;skipFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&lt;node_internals&gt;/**&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;node_modules/**&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-运行调试"><a href="#2-运行调试" class="headerlink" title="2. 运行调试"></a>2. 运行调试</h4><ol><li>打开 VS Code。</li><li>在调试面板中选择 <code>Debug Vitest Tests</code> 配置。</li><li>设置断点。</li><li>启动调试。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vitest 利用 Vite 的 TypeScript 支持和 source maps，能够轻松处理和调试 TypeScript 文件。通过正确配置项目和调试器，开发者可以在 Vitest 中进行有效的 TypeScript 单元测试和调试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>源代码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vitest 调试命令分析（chatgpt 回答）</title>
    <link href="/blog/2024/07/12/vitest%20%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90/"/>
    <url>/blog/2024/07/12/vitest%20%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>问：PS E:\open-source-code\vue&gt;  e:; cd ‘e:\open-source-code\vue’; ${env:NODE_OPTIONS}=’ –require “d:/Users/wxc/AppData/Local/Programs/Microsoft VS Code/resources/app/extensions/ms-vscode.js-debug/src/bootloader.js”  –inspect-publish-uid=http’; ${env:VSCODE_INSPECTOR_OPTIONS}=’:::{“inspectorIpc”:”\\.\pipe\node-cdp.12196-f5e0f071-16.sock”,”deferredMode”:false,”waitForDebugger”:””,”execPath”:”D:\Program Files\nodejs\node.exe”,”onlyEntrypoint”:false,”autoAttachMode”:”always”,”fileCallback”:”C:\Users\wxc\AppData\Local\Temp\node-debug-callback-21397b8897f6c36d”}’; &amp; ‘D:\Program Files\nodejs\node.exe’ ‘.\node_modules\vitest\vitest.mjs’ ‘run’ ‘test\unit\features\directives\if.spec.ts’  Debugger attached  解释这一整条命令</p><p>这条命令是一段 PowerShell 脚本，用于在 Visual Studio Code（VS Code）调试环境中运行特定的 Node.js 程序，并且附加调试器。它主要用于在调试模式下运行 Vitest 测试。这是对这条命令的逐步解释：</p><h3 id="1-切换到特定目录"><a href="#1-切换到特定目录" class="headerlink" title="1. 切换到特定目录"></a>1. 切换到特定目录</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">e:; <span class="hljs-built_in">cd</span> <span class="hljs-string">&#x27;e:\open-source-code\vue&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>e:</code>：切换到 E 盘。</li><li><code>cd &#39;e:\open-source-code\vue&#39;</code>：进入 <code>e:\open-source-code\vue</code> 目录。</li></ul><h3 id="2-设置环境变量-NODE-OPTIONS"><a href="#2-设置环境变量-NODE-OPTIONS" class="headerlink" title="2. 设置环境变量 NODE_OPTIONS"></a>2. 设置环境变量 NODE_OPTIONS</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span>&#123;env:NODE_OPTIONS&#125;=<span class="hljs-string">&#x27; --require &quot;d:/Users/wxc/AppData/Local/Programs/Microsoft VS Code/resources/app/extensions/ms-vscode.js-debug/src/bootloader.js&quot;  --inspect-publish-uid=http&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>NODE_OPTIONS</code>：这是一个 Node.js 环境变量，用于传递额外的选项给 Node.js。</li><li><code>--require &quot;d:/Users/wxc/AppData/Local/Programs/Microsoft VS Code/resources/app/extensions/ms-vscode.js-debug/src/bootloader.js&quot;</code>：使用 <code>require</code> 选项加载一个初始脚本。这个脚本是 VS Code 用来启动调试器的引导程序。</li><li><code>--inspect-publish-uid=http</code>：启用调试器，并通过 HTTP 协议发布调试 UID。</li></ul><h3 id="3-设置环境变量-VSCODE-INSPECTOR-OPTIONS"><a href="#3-设置环境变量-VSCODE-INSPECTOR-OPTIONS" class="headerlink" title="3. 设置环境变量 VSCODE_INSPECTOR_OPTIONS"></a>3. 设置环境变量 VSCODE_INSPECTOR_OPTIONS</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span>&#123;env:VSCODE_INSPECTOR_OPTIONS&#125;=<span class="hljs-string">&#x27;:::&#123;&quot;inspectorIpc&quot;:&quot;\\\\.\\pipe\\node-cdp.12196-f5e0f071-16.sock&quot;,&quot;deferredMode&quot;:false,&quot;waitForDebugger&quot;:&quot;&quot;,&quot;execPath&quot;:&quot;D:\\Program Files\\nodejs\\node.exe&quot;,&quot;onlyEntrypoint&quot;:false,&quot;autoAttachMode&quot;:&quot;always&quot;,&quot;fileCallback&quot;:&quot;C:\\Users\\wxc\\AppData\\Local\\Temp\\node-debug-callback-21397b8897f6c36d&quot;&#125;&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>VSCODE_INSPECTOR_OPTIONS</code>：这是一个 VS Code 特定的环境变量，用于配置调试器。</li><li>这个 JSON 字符串包含了多个配置项，如调试器的 IPC 通信路径、执行路径、自动附加模式等。</li></ul><h3 id="4-运行-Node-js-程序"><a href="#4-运行-Node-js-程序" class="headerlink" title="4. 运行 Node.js 程序"></a>4. 运行 Node.js 程序</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&amp; <span class="hljs-string">&#x27;D:\Program Files\nodejs\node.exe&#x27;</span> <span class="hljs-string">&#x27;.\node_modules\vitest\vitest.mjs&#x27;</span> <span class="hljs-string">&#x27;run&#x27;</span> <span class="hljs-string">&#x27;test\unit\features\directives\if.spec.ts&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>&amp;</code>：在 PowerShell 中用于运行命令。</li><li><code>&#39;D:\Program Files\nodejs\node.exe&#39;</code>：指定 Node.js 的可执行文件路径。</li><li><code>&#39;.\node_modules\vitest\vitest.mjs&#39;</code>：指定要运行的 Vitest 测试框架的入口文件。</li><li><code>&#39;run&#39; &#39;test\unit\features\directives\if.spec.ts&#39;</code>：传递给 Vitest 的参数，表示运行特定的测试文件 <code>test\unit\features\directives\if.spec.ts</code>。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这条命令在以下步骤中运行：</p><ol><li>切换到 <code>e:\open-source-code\vue</code> 目录。</li><li>设置 <code>NODE_OPTIONS</code> 环境变量以加载 VS Code 调试引导程序并启用调试器。</li><li>设置 <code>VSCODE_INSPECTOR_OPTIONS</code> 环境变量以配置调试器选项。</li><li>使用 Node.js 执行 Vitest 测试框架，并运行指定的测试文件 <code>test\unit\features\directives\if.spec.ts</code>。</li></ol><p>最终，这条命令的目的是在 VS Code 的调试环境中运行一个特定的 Vitest 测试文件，并附加调试器以便调试测试过程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>源代码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa 中间件源代码分析</title>
    <link href="/blog/2024/06/26/Koa%20%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/blog/2024/06/26/Koa%20%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>首先是通过 app.use 收集中间件函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Use the given middleware `fn`.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Old-style middleware will be converted.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">fn</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Application</span>&#125; <span class="hljs-variable">self</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-title function_">use</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;middleware must be a function!&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isGeneratorFunction</span>(fn)) &#123;<br>    <span class="hljs-title function_">deprecate</span>(<span class="hljs-string">&#x27;Support for generators will be removed in v3. &#x27;</span> +<br>              <span class="hljs-string">&#x27;See the documentation for examples of how to convert old middleware &#x27;</span> +<br>              <span class="hljs-string">&#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;</span>);<br>    fn = <span class="hljs-title function_">convert</span>(fn);<br>  &#125;<br>  <span class="hljs-title function_">debug</span>(<span class="hljs-string">&#x27;use %s&#x27;</span>, fn.<span class="hljs-property">_name</span> || fn.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;-&#x27;</span>);<br>  <span class="hljs-comment">// 收集中间件函数到数组中</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>.<span class="hljs-title function_">push</span>(fn);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回一个用于原生 http server 的回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return a request handler callback</span><br><span class="hljs-comment"> * for node&#x27;s native http server.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Function</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 构建中间件机制模型</span><br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">middleware</span>);<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&#x27;error&#x27;</span>)) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">onerror</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">req, res</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createContext</span>(req, res);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">ctxStorage</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>    &#125;<br>      <span class="hljs-comment">// 执行中间件相关函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctxStorage</span>.<span class="hljs-title function_">run</span>(ctx, <span class="hljs-title function_">async</span>() =&gt; &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleRequest</span>(ctx, fn);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> handleRequest;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>中间件机制模型 koa-compose</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Expose compositor.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = compose<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Compose `middleware` returning</span><br><span class="hljs-comment"> * a fully valid middleware comprised</span><br><span class="hljs-comment"> * of all those which are passed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; <span class="hljs-variable">middleware</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Function</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span> (middleware) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middleware)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware stack must be an array!&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middleware) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@api</span> <span class="hljs-variable">public</span></span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-comment">// 中间件机制核心代码</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) &#123;<br>    <span class="hljs-comment">// last called middleware #</span><br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">i</span>) &#123;<br>      <span class="hljs-comment">// i 始终大于 index, 否则是 next 被调用多次</span><br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i] <span class="hljs-comment">// 获取到当前执行的中间件函数</span><br>      <span class="hljs-keyword">if</span> (i === middleware.<span class="hljs-property">length</span>) fn = next <span class="hljs-comment">// 如果 i-arr.length 那么则执行完毕，fn === undefined ，</span><br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>() <span class="hljs-comment">// 当 fn 处于 undefined 时，结束执行，</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(context, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>))); <span class="hljs-comment">// 执行 中间件函数，并且把dispath(i+1) 当作是 next（中间件函数内部的 next ） 函数执行</span><br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>源代码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>p-limit 源代码分析</title>
    <link href="/blog/2024/05/09/p-limit%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/blog/2024/05/09/p-limit%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>之前在狼叔的了不起的Nodejs 书中接触到这个库，了解了一下，觉得很有意思。虽然实际工作中没有接触过大量并发的业务，但是了解一下极端情况下JS异步任务的调度也是挺不错的。</p><p>下面是智普清言的介绍：</p><blockquote><p><code>p-limit</code> 是一个 Node.js 和浏览器都支持的库，用于限制并发执行的数量。它基于 <code>p-queue</code>，是一个用于控制异步任务队列的库，可以确保同时只有指定数量的异步操作在进行。<br>以下是一些可能使用 <code>p-limit</code> 的情况：</p><ol><li><strong>限制并发请求数量</strong>：在进行大量异步网络请求（例如使用 <code>fetch</code> 或 <code>axios</code>）时，为了避免服务器过载或达到API限制，可以使用 <code>p-limit</code> 来限制同时发出的请求数量。</li><li><strong>资源密集型任务</strong>：当执行一些CPU或内存密集型的任务时，如果同时运行太多的任务可能会影响系统性能，使用 <code>p-limit</code> 可以确保系统资源得到合理分配。</li><li><strong>文件处理</strong>：在处理大量文件读写操作时，为了防止磁盘I/O成为瓶颈，可以使用 <code>p-limit</code> 来限制并发文件操作的数量。</li><li><strong>数据库操作</strong>：在进行数据库批量操作时，为了避免过多的并发连接导致数据库响应缓慢或超时，可以使用 <code>p-limit</code> 来限制并发数据库操作的数量。</li><li><strong>API节流</strong>：如果你正在开发一个需要调用第三方服务API的应用，并且该API对请求频率有限制，使用 <code>p-limit</code> 可以帮助你控制请求的速率，避免触发API的限制。</li><li><strong>提高成功率</strong>：在某些情况下，限制并发数可以提高任务的成功率，因为减少了同时操作可能导致的冲突或错误。<br>使用 <code>p-limit</code> 可以帮助你更好地控制异步流程，确保系统的稳定性和性能。它通过创建一个限制器实例，并指定最大并发数，然后使用这个限制器来包装异步任务，从而实现并发控制。</li></ol></blockquote><p>下面是核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Queue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;yocto-queue&#x27;</span>; <span class="hljs-comment">// 一个双端队列</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AsyncResource</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;#async_hooks&#x27;</span>; <span class="hljs-comment">// 提供简单的函数 bind 操作</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pLimit</span>(<span class="hljs-params">concurrency</span>) &#123;<br><span class="hljs-keyword">if</span> (!((<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(concurrency) || concurrency === <span class="hljs-title class_">Number</span>.<span class="hljs-property">POSITIVE_INFINITY</span>) &amp;&amp; concurrency &gt; <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Expected `concurrency` to be a number from 1 and up&#x27;</span>);<br>&#125; <span class="hljs-comment">// 参数校验，必须为正整数</span><br><br><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();<br><span class="hljs-keyword">let</span> activeCount = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>activeCount--;<br><br><span class="hljs-keyword">if</span> (queue.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;next 前&quot;</span>);<br>queue.<span class="hljs-title function_">dequeue</span>()(); <span class="hljs-comment">// 开始执行第二个任务， run</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;next 后&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">function_, resolve, arguments_</span>) =&gt; &#123;<br>activeCount++;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res 前&quot;</span>, function_.<span class="hljs-title function_">toString</span>());<br><span class="hljs-keyword">const</span> result = (<span class="hljs-keyword">async</span> () =&gt; <span class="hljs-title function_">function_</span>(...arguments_))();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res 后&quot;</span>, function_.<span class="hljs-title function_">toString</span>());<br><br><span class="hljs-title function_">resolve</span>(result);<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;await 前&quot;</span>, function_.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Promise.all 将第一个异步任务执行到这</span><br><span class="hljs-keyword">await</span> result;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;await 后&quot;</span>, function_.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 发现二、三都执行不了的时候，主线程又回到这里继续执行第一个</span><br>&#125; <span class="hljs-keyword">catch</span> &#123;&#125;<br><br><span class="hljs-title function_">next</span>();<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">enqueue</span> = (<span class="hljs-params">function_, resolve, arguments_</span>) =&gt; &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;已经入队&quot;</span>, function_.<span class="hljs-title function_">toString</span>());<br>queue.<span class="hljs-title function_">enqueue</span>(<br><span class="hljs-title class_">AsyncResource</span>.<span class="hljs-title function_">bind</span>(run.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">undefined</span>, function_, resolve, arguments_)),<br>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步开启&quot;</span>, function_.<span class="hljs-title function_">toString</span>());<br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br><span class="hljs-comment">// This function needs to wait until the next microtask before comparing</span><br><span class="hljs-comment">// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously</span><br><span class="hljs-comment">// when the run function is dequeued and called. The comparison in the if-statement</span><br><span class="hljs-comment">// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步前&quot;</span>, function_.<span class="hljs-title function_">toString</span>());<br><span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(); <span class="hljs-comment">// 首先三个注册的异步任务都会指定到这个 await , 保存执行栈，后面的代码放到微任务队列。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步后&quot;</span>, function_.<span class="hljs-title function_">toString</span>());<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;已经执行&quot;</span>, function_.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 当 Promise.all 执行第二、三个任务的时候，由于并发数量限制，所以又停在这里</span><br><span class="hljs-keyword">if</span> (activeCount &lt; concurrency &amp;&amp; queue.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;准备出队&quot;</span>, function_.<span class="hljs-title function_">toString</span>());<br>queue.<span class="hljs-title function_">dequeue</span>()();<br>&#125;<br>&#125;)();<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generator</span> = (<span class="hljs-params">function_, ...arguments_</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br><span class="hljs-title function_">enqueue</span>(function_, resolve, arguments_);<br>&#125;); <span class="hljs-comment">// 把异步任务包装成 Promise, 把改变 Promise 状态的 resolve 和函数、参数入队</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(generator, &#123;<br><span class="hljs-attr">activeCount</span>: &#123;<br><span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> activeCount,<br>&#125;,<br><span class="hljs-attr">pendingCount</span>: &#123;<br><span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> queue.<span class="hljs-property">size</span>,<br>&#125;,<br><span class="hljs-attr">clearQueue</span>: &#123;<br><span class="hljs-title function_">value</span>(<span class="hljs-params"></span>) &#123;<br>queue.<span class="hljs-title function_">clear</span>();<br>&#125;,<br>&#125;,<br>&#125;); <span class="hljs-comment">// 定义获取生成器的运行状态信息的函数</span><br><br><span class="hljs-keyword">return</span> generator;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js">已经入队 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>异步开启 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>异步前 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>已经入队 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>异步开启 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>异步前 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>已经入队 () =&gt; <span class="hljs-title function_">doSomething</span>()<br>异步开启 () =&gt; <span class="hljs-title function_">doSomething</span>()<br>异步前 () =&gt; <span class="hljs-title function_">doSomething</span>()<br><span class="hljs-title class_">All</span> <span class="hljs-title class_">Promise</span> 前<br>异步后 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>已经执行 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>准备出队 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>res 前 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>res 后 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-keyword">await</span> 前 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>异步后 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>已经执行 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>异步后 () =&gt; <span class="hljs-title function_">doSomething</span>()<br>已经执行 () =&gt; <span class="hljs-title function_">doSomething</span>()<br><span class="hljs-keyword">await</span> 后 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>next 前<br>res 前 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>res 后 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-keyword">await</span> 前 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>next 后<br><span class="hljs-keyword">await</span> 后 () =&gt; <span class="hljs-title function_">fetchSomething</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>next 前<br>res 前 () =&gt; <span class="hljs-title function_">doSomething</span>()<br>res 后 () =&gt; <span class="hljs-title function_">doSomething</span>()<br><span class="hljs-keyword">await</span> 前 () =&gt; <span class="hljs-title function_">doSomething</span>()<br>next 后<br><span class="hljs-keyword">await</span> 后 () =&gt; <span class="hljs-title function_">doSomething</span>()<br><span class="hljs-title class_">All</span> <span class="hljs-title class_">Promise</span> 后<br>[ <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span> ]<br>foo<br>bar<br>doSomething<br></code></pre></td></tr></table></figure><p>总结就是对嵌套调用的 async await ，await 调用的表达式，必须执行完整，才会往下执行。对于内部 await 阻塞的语句，会先执行可以执行的。被称为主线程代码（相对来说）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncFunc1</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 before&quot;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>((<span class="hljs-keyword">async</span> () =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise before&quot;</span>)<br>        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise after&quot;</span>)<br>    &#125;)());<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 after&quot;</span>)<br>&#125;<br><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncFunc2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async2 before&quot;</span>);<br>    <span class="hljs-title function_">asyncFunc1</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async2 after&quot;</span>)<br>&#125;<br><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncFunc3</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async3 before&quot;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunc2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async3 after&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFunc3</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;main func&quot;</span>)<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">async3 before<br>async2 before<br>async1 before<br>promise before<br>async2 after<br>promise after<br>async3 after<br>async1 after<br>main func<br></code></pre></td></tr></table></figure><p>疑问： async3 为什么在 async1之前？</p>]]></content>
    
    
    
    <tags>
      
      <tag>源代码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端代码小抄发布</title>
    <link href="/blog/2024/05/08/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%B0%8F%E6%8A%84/"/>
    <url>/blog/2024/05/08/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%B0%8F%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hercules11.github.io/frontend-cheat-sheet/">前端代码小抄</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>代码小抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express cors 中间件和自定义中间件函数设置 Header 的区别</title>
    <link href="/blog/2024/03/25/Express-cors-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE-Header-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2024/03/25/Express-cors-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE-Header-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>今天又踩了个大坑，问题是这样的。<br>我正在使用 <code>GraphQL</code> 的 SANDBOX 环境测试接口，需要 <code>Express</code> 配置跨域。origin 的值是 <code>https://studio.apollographql.com</code> , 本来是一件很简单的事情，但是我又折腾了一个下午。</p><p>一开始沙盒环境请求 <code>http://localhost:8080/graphql</code> 报错，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at [http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/graphql](http:/</span><span class="hljs-regexp">/localhost:8080/g</span>raphql <span class="hljs-string">&quot;http://localhost:8080/graphql&quot;</span>). (Reason: CORS request did not succeed). Status code: (null).<br></code></pre></td></tr></table></figure><p>我心想这简单，配置一下<code> Access-Control-Allow-Origin</code> 设置为 <code>*</code> 即可。但是呢，因为后续需要模拟登录状态，保存 Cookie, 需要设置 <code>Access-Control-Allow-Credentials</code> 为 <code>true</code>, 那么 <code>Access-Control-Allow-Origin</code> 就不能为 <code>*</code> 通配符了。所以 <code>Access-Control-Allow-Origin</code> 需要设置为具体的值 <code>https://studio.apollographql.com</code> ，形成一个类似于白名单的效果。<br><br>最终的设置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<br>        <span class="hljs-string">&quot;https://studio.apollographql.com&quot;</span><br>    );<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>,<br>        <span class="hljs-string">&quot;GET,HEAD,PUT,PATCH,POST,DELETE&quot;</span><br>    );<br>    <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>但是 <code>GraphQL</code> 的沙盒环境还是一直报错，<code>405 Method Not Allowed</code> , 即使设置了 <code>Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE</code> 也不行，预检请求响应字段里面还有一个 <code>ALLOW: &quot;GET, POST&quot;</code>, 看了一下 MDN 文档，发现是 405 的响应必须要一个 ALLOW 字段，显示当前 server 支持的请求方法列表。</p><p><strong>我的疑惑来了，我明明配置了跨域的请求方法，为什么还会报错</strong>？</p><p>想了好久。<br><br>用 <code>cors</code> 中间件设置跨域的参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-title function_">cors</span>(&#123;<br>        <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">origin</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">CLIENT_URL</span>,<br>    &#125;)<br>);<br></code></pre></td></tr></table></figure><p>居然就不报错了，奇怪啊。去翻看了一下 <code>cors</code> 的源代码，不长，就两百多行。</p><p>我发现除了一些基础的配置之外， <code>cors</code> 做了一个判断，当请求的方法是 <code>OPTIONS</code> 的时候，直接 <code>res.end()</code> 结束了响应，而其他情况，则调用 <code>next()</code>, 继续往下运行。</p><p>到这个时候，我明白了。<br><br>OPTIONS 预检请求，是询问 server 是否当前 origin 可以访问，一般来讲，预检请求成功返回，就是代表 origin 可以做请求了（由浏览器控制）。这个时候，server 再定义一些字段来精细化控制后续的请求。<br><br>我遇到的情况报错是因为, 针对预检请求，没有做特殊处理，导致后续的 <code>Apollo Server</code> 对这个 <code>OPTIONS</code> 请求报错了，导致预检请求失败。前面所做的配置，也就无效了。<br><br>所以说, 自定义预检请求的中间件函数应该这样写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;<br>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<br>        <span class="hljs-string">&quot;https://studio.apollographql.com&quot;</span><br>    );<br>    res.<span class="hljs-title function_">setHeader</span>(<br>        <span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>,<br>        <span class="hljs-string">&quot;GET,HEAD,PUT,PATCH,POST,DELETE&quot;</span><br>    );<br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>        res.<span class="hljs-title function_">send</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">next</span>();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>针对预检请求，设置完参数后，直接返回，不要让后续的中间件再进行处理了。<br><br>弄清楚问题后，我直接注释了我写的配置，直接使用用 <code>cors</code> 中间件配置, 一了百了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ts-node-dev + redis 运行 demo 踩坑记录</title>
    <link href="/blog/2024/03/19/ts-node-dev-redis-%E8%BF%90%E8%A1%8C-demo-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/blog/2024/03/19/ts-node-dev-redis-%E8%BF%90%E8%A1%8C-demo-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>运行一个后端的小 demo, 技术栈是 ts-node-dev + redis + express。耽误了一整天, 就做了这点事, 不写个文章记录一下，真对不起我花的这么多时间。</p><p>第一个坑点:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">error TS2688: Cannot find <span class="hljs-keyword">type</span> definition <span class="hljs-keyword">file</span> for <span class="hljs-string">&#x27;ioredis&#x27;</span>.<br>  The <span class="hljs-keyword">file</span> is <span class="hljs-keyword">in</span> the <span class="hljs-function"><span class="hljs-keyword">program</span></span> because:<br>    <span class="hljs-built_in">Entry</span> point for <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">type</span> library <span class="hljs-string">&#x27;ioredis&#x27;</span><br></code></pre></td></tr></table></figure><p>这是 <code>tsconfig.json</code> 文件报的错。疑惑的是，我明明安装了 <code>@types/ioredis</code> 依赖包，似乎没有起作用。去搜索了一下原因，发现仓库赫然写着:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Author message:<br><br>This <span class="hljs-keyword">is</span> a stub types definition. ioredis provides its own <span class="hljs-keyword">type</span> <span class="hljs-type">definitions, </span>so you <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> need this installed.<br></code></pre></td></tr></table></figure><p>也看了其他的解决方案，说是把版本降到 4.x。但是呢，我想着作者已经用 ts 升级了依赖，为什么还要走老路呢。于是我干脆利落地卸载了 <code>@types/ioredis</code>。发现问题并没有解决，<strong>遇事不绝，重启 vscode</strong>。再次打开项目时，第一个问题真的解决好了。</p><p>第二个坑点：<br><code>error TS2339: Property &#39;userid&#39; does not exist on type &#39;Session &amp; Partial&lt;SessionData&gt;&#39;</code>, 这个问题一看就是定义的属性不存在于 <code>Seesion</code> 类型上面。但是这里我们需要把自定义的数据属性放到 <code>req.session</code> 对象上，就必须要用到自定义属性，怎么解决呢？去找了一些解决方案，发现可以使用 ts 的 <code>Declaring Merging</code> <strong>声明融合</strong>功能，为原先的类型扩充属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Session</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express-session&quot;</span>;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;express-session&quot;</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Session</span> &#123;<br>        <span class="hljs-attr">userid</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>        <span class="hljs-attr">loadedCount</span>: <span class="hljs-built_in">number</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三个坑点: 自定义的类型没有生效，查看了一些解决方案后，发现可以为 <code>tsconfig.json</code> 配置文件添加 <code>typeRoots</code> 属性值。<br>像这样</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;typeRoots&quot;</span>: [<br>      <span class="hljs-string">&quot;./src/types&quot;</span>, <span class="hljs-regexp">//</span> this is where you define your types<br>       <span class="hljs-string">&quot;./node_modules/@types&quot;</span> <span class="hljs-regexp">//</span>this where npm packages containing types are located<br>    ],                                  <span class="hljs-regexp">/* Specify multiple folders that act like &#x27;./</span>node_modules<span class="hljs-regexp">/@types&#x27;. */</span><br></code></pre></td></tr></table></figure><p>定义了类型后，发现 vscode 的错误提示还是存在，没办法，再次重启。好了，红色波浪线不见了，但是命令行运行 <code>ts-node-dev --respawn src/index.ts</code> 还是报错, 属性不存在, 愁死我了。心想，<code>ts-node-dev</code> 是不是没有加载根目录的配置文件。看到启动 <code>ts-node-dev</code> 打印的 ts 版本与当前项目的 ts 版本不一致，让我觉得这样想准没错。找了半天文档，没看见啥命令行 options 可以打印当前的配置的。问题再度陷入了僵局，我左思右想，在 <code>ts-node-dev</code> 的 npm 仓库介绍，看到这样一句话</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Tweaked <span class="hljs-keyword">version</span> of <span class="hljs-keyword">node</span><span class="hljs-title">-dev</span> that uses ts-<span class="hljs-keyword">node</span> <span class="hljs-title">under</span> the hood.<br></code></pre></td></tr></table></figure><p>是不是应该从 <code>ts-node</code> 寻找突破口。<br>果然让我发现了 <code>--showConfig</code> 可以打印配置信息，前往 vscode 终端一试，发现我自定义的类型文件是包含在里面的。也就是说，定义的配置文件是加载到了，问题又进入了僵局。<br>接着搜索名，看看其他人有什么解决方案。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">By default, `ts-node` does <span class="hljs-literal">not</span> load `files`, `include` <span class="hljs-literal">or</span> `exclude` from `tsconfig.json` on startup. The `--files` option enables it.<br><br><span class="hljs-title">See &lt;https:</span>//github.com/TypeStrong/ts-node#missing-types&gt;<br></code></pre></td></tr></table></figure><p>终于破案了，这个坑太大了，谁能想得到。因为 <code>ts-node-dev</code> 是基于 <code>ts-node</code> 构建的，对于后者有效的配置，前者也有效。终于耗了我一整个下午的问题终于解决了。</p><p>第四个坑点:<br><code>TypeError: Class constructor RedisStore cannot be invoked without &#39;new&#39;</code>。问题还是出在教学示例使用的依赖版本偏低了。升级后的依赖做了 breaking changes。找到了官方发布的 <a href="https://github.com/tj/connect-redis/releases/tag/v7.0.0">release log</a>。重写了实例化 redisStore 的代码。现在一切正常了。</p><p>总结反思：学习编程就是这样不断的发现问题，解决问题的过程。解决问题的思路，会越来越开阔，随着对问题的刨析，也会越来越清晰。这就是编程的魅力啊。</p>]]></content>
    
    
    
    <tags>
      
      <tag>后端开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH 远程登录要点解析</title>
    <link href="/blog/2024/03/08/SSH%20%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E8%A6%81%E7%82%B9%E8%A7%A3%E6%9E%90/"/>
    <url>/blog/2024/03/08/SSH%20%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E8%A6%81%E7%82%B9%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>最近打算学习一下 Node 源代码，在虚拟机上安装 Linux 的桌面版后，用 VSCODE 打开代码非常不方便，总是带着个虚拟机的外壳（VMware Workstation）。于是就想到用 VSCODE 的远程开发。按照<a href="https://juejin.cn/post/7176469208161747005">网上的教程</a>配置好 SSH 密钥后，现在可以非常顺滑的连接虚拟机了。步骤中涉及的要素有点多，想着写篇文章记录一下各个要素的关系。</p><p>涉及的要素有：<br><br>Host: Windows 10, SSH Client, known_hosts, config<br><br>Server: Ubuntu 22.04, SSH Server, authorized_keys</p><p>关系：<br><br>首先生成密钥对，SSH Client 和 SSH Server 使用密钥对进行通信。<br><br>而后，将生成的公钥 <code>id_rsa.pub</code> 内容放到 SSH Server 上的 <code>~/.ssh/authorized_keys</code> 文件里，注意它是文件，不是文件夹。<br><br><code>sudo reboot</code> 重启 SSH Server。<br>最后就可以用 <code>ssh -i ~/.ssh/你的私钥 username@remote_host</code> 登录 SSH Server（生成密钥的时候没有设置密钥，那就不需要输入密码）。<br>如果登录失败，又或是有其他问题，不符合预期，可以通过 <code>service sshd status</code> 查看登录日志，进一步了解情况。</p><p>其他：(from gpt)<br></p><ol><li>known_hosts: <ul><li>文件包含了远程服务器公钥的指纹。当 SSH Client 首次连接到一台新服务器的时候，它会将服务器的公钥添加到 known_hosts 文件中。</li><li>每当 SSH client 尝试连接到已知的主机时，它会使用 <code>known_hosts</code> 文件中的公钥指纹来验证服务器的身份。如果公钥指纹与 <code>known_hosts</code> 文件中的指纹匹配，连接将继续进行。</li><li>如果公钥指纹不匹配，SSH client 会警告用户可能存在中间人攻击，并询问用户是否仍然希望继续连接。</li></ul></li><li>config:（VSCODE会读取这个文件用于连接远程服务器）<ul><li>文件允许用户为 SSH 连接设置全局或特定于主机的选项。例如，你可以设置端口号、用户、身份文件、禁用密码认证等。</li><li>配置文件通常位于用户的家目录下的 <code>.ssh</code> 文件夹中。</li><li>例如，以下是一个配置文件的示例，它设置了一个特定主机的用户和身份文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Host remote_server<br>  User myuser<br>  HostName remote_host.com<br>  Port 2222<br>  IdentityFile ~/.ssh/mykey<br></code></pre></td></tr></table></figure></li></ul></li><li>authorized_keys:<ul><li>文件包含了一系列的公钥，这些公钥被服务器用来验证连接的客户端。</li><li>当客户端尝试通过 SSH 密钥认证连接到服务器时，它会发送其公钥。服务器会检查 <code>authorized_keys</code> 文件，看是否有匹配的公钥，然后使用该公钥对应的私钥进行验证。</li><li>如果在 <code>authorized_keys</code> 文件中找到了匹配的公钥，服务器将接受连接，并且允许客户端无密码登录。</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>25岁的低水平人生</title>
    <link href="/blog/2024/02/18/25%E5%B2%81%E7%9A%84%E4%BD%8E%E6%B0%B4%E5%B9%B3%E4%BA%BA%E7%94%9F/"/>
    <url>/blog/2024/02/18/25%E5%B2%81%E7%9A%84%E4%BD%8E%E6%B0%B4%E5%B9%B3%E4%BA%BA%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>年前刚满了 25 岁，现在四舍五入也算是接近 30 岁的人了。可是，至今没有什么拿得出手的东西，在社会上立足。其实也还好，工作了两年多，身上还有几万存款，够我躺平几个月好好想想我到底要干什么。</p><p>以前在学校（高中以前），成绩尚可，就心高气傲地宣告，自己是要做大事的人，要维护世界和平，促进人类共同发展。现在想想，真够可笑的，温饱尚不能够，更别提理想了。到了大学，才是人生步入低谷的开始。开始接触社会了，开始用到学习以外的其他技能了，开始处理各种人际关系了。各种让我不适应。假设存在一种正常人的生活方式，那么我离这种正常的生活方式差距挺大的。</p><p>倒不是我矫情，读完本科出来，原以为已经到社会中上的水平了，其实连前50%都不到。看过深圳市的工资水平调查，我的薪资在就是就是行业也就前75%的水平。也真是够低的。</p><p>那么，好好想一想，是什么原因导致的这个结果？</p><ol><li><p>性格原因，不敢尝试更高薪资的工作，怕承受不了老板的期望，不敢去面试高薪的工作，怕被拒绝，不敢主动解决问题，怕担上事情。</p></li><li><p>技术水平不行，学习的方式还是以前那种遍历知识点式的学习。回顾过往的学习经历，高中开始，喜欢学习偏难怪的知识点，以此为荣；结果高考也就上个普通一本；上了大学，继续之前的学习方式，以考促学，好歹学了点东西，但也都是把知识点塞进脑子里，过一段时间就忘了；后面学习了 office 二级，六十多分飘过，技能也学的一般。可能好处在于初步具备了按照需求学习的能力；后面学习c语言，记忆各种语法点，以为这就是编程，结果碰到写项目就死菜了；c语言考试也是背过去的；到后面，学习考研英语，以为可以弯道超车，出奇制胜，结果只剩在图书馆蹭 wifi 刷知乎, 最后也就考了 72 , 还是低于自己的预期。。。</p></li></ol><p>到了大学毕业，也没决定要做什么好。</p><p>毕业前期，觉得知乎上各种案例分析很好玩，就想着去做律师，也想着考个律师证书做法律援助，或者去县城做个公务员啥的。结果发现自己只是叶公好龙罢了。看到辅导书整页的案例分析，法理分析，顿时觉得无趣。又想着与其考完研究生再去考公务员，不如直接考三年，为了逼自己下定决定，买了150多块的考公书籍，后面发现没有什么能考的岗位，只有乡镇可选，又泄了气；看了军队文职，也觉得是一条出路，但想到各种萝卜坑，各种偏僻的小县城，真觉得没必要，也是买了资料书就放到一边了。我也不知道自己要干什么比较好，不认命，又没有确定的目标，也不会规划路径，真是秀逗了。</p><p>也是受到知乎轮子哥的影响，说要做自己喜欢的事情，才有无穷的动力，也不用管工资高低，如果入不了行，也可以先干别的，再转进来。</p><p>后面偶然搜了一下如何学习计算机，发现了 Teach-Yourself-CS 这篇文章，我大受震惊。于是在毕业前期，按照教程，开始学习《计算机系统要素》，并一直在脑海里默念（程序，架构，算法，数学，操作系统，网络，数据库，编译原理，分布式）彷佛学了这些以后，就可以成为计算机大神了。刚开始一个月，学习《计算机系统要素》，还挺顺利，挺有成就感的。按照与非门的逻辑，搭建更高复杂度的逻辑门电路。这个时候，我好像发现，厉害的人，做什么都厉害；菜鸡，通过一些事情的磨练，更可能成为一个熟练工。厉害的人，比如上海交大的迟先生，后面去了CMU，还帮老师改进研究生课程。菜鸡比如我，CPU 的逻辑搭建不出来，看答案，操作系统的逻辑搭建不出来，看别人解析也不会。</p><p>或许，改进思维方式，才是让自己能力进阶的法门。</p><p>20 年七月，毕业回到家，继续做着我的计算机成神的春秋大梦，在破烂的空屋，破烂的床上，用小桌子搭建一个平台。写着半生不熟的 Python，做计算机系统要素的项目。由于编程基础太差，又去花了一两个月学习 cs61a，有了成效之后，接着写计算机系统要素的项目。这种按照书本上提出的模式，去写代码程序的感觉真好，每天都觉得能力突飞猛进。</p><p>借着在家考研的由头，在家已经蹲了半年了，家里蹲终究不是办法，父亲也不好跟别人说你家儿子毕业后在干嘛。为了避免过年时候的尴尬，也是因为疫情各地封禁，我决定只身前去广州找工作。于是 2021-01-22 去了大学城，找了一家青旅住了下来，一个月 七百的房租，房间里基本没有光线。我想这没什么大不了的，我要从这里飞到全世界的各个角落（又树立了一轮雄心壮志）。于是开始写简历，得了，写简历没啥可写的。还是要接地气一点，看看时下热门的行业，于是我又开始学习前端（毕业设计做过全栈的项目）。花了点时间学习 freecodecamp 上面的教程，把一些简单功能的写法记住了，写到了简历上（现在看来真是惨不忍睹，小儿科的东西）。也难怪投简历的时候，没人理我，只有培训公司愿意叫我面试了。转眼已经到了六月份，身上没多少钱了，当初出来的时候就问家里要了五千多，后面没敢找工作，也一直没和家里联系（混得差，没脸见人），真是够混蛋的。找了几天，只有几个培训班愿意要我试岗，面试。此时我的心气已经被磨平了，去找了<code>老陈打码</code>，我做毕业设计就是看的他的视频。他说我就不要要价那么低（五千），说十五元的盒饭卖五元，你敢买吗？给我介绍了一个培训课程，四千块，一个月速成。可是，那会我身上只有两千多了，房租生活费一个月接近一千五。无奈，只好去求助了老姐，他就叫我进工厂，借钱肯定是不行的。于是坐着姐夫的车，去了花都，租了一个月两百多的房子，也是没有日光。想着此时此刻，我又发下宏愿，我会从这里开始飞黄腾达。后续就是面试工厂文员、普工过于实诚，导致前面三家都没要我。去了圆通快递，做了两天快递分拣，一个月四千，月休两天。我一看有人要我了，连忙答应下来。就去干活了。但是组长迟迟不和我说签合同的事情，可能是怕我做不长。快递分拣，就是车来了，就要卸货，导致工作时间段很分散，早上五六点就要去干一段时间，真折磨人啊。我姐就叫我别干了，又去找了化妆品厂。这回面试学聪明了，我说以前是干快递的，想找份轻松的工作。于是，顺利入职zuoyi。</p><p>除去以前做保安，做服务员的兼职经历不算，这算是第一份工作。工作内容挺简单的，就是给化妆品折叠盒子，贴标签，做罐装等等。底薪2600+200 全勤，加班算1.5 倍工资，单休。期间，组长看我比较有文化，就叫我担任贴标员的职位，还有质量检测的工位。一天上午四小时，下午四小时，其他没什么感觉，就是非常困，困得要死，不知道为什么。后面还经历了夜班半个月，真是欲仙欲死。整天都没活力。干了三个月，最后还是离职了，刚好一百天左右。周末在老姐家吃饭。平时就买一些饮料，还挺省钱的。攒了接近一万块。</p><p>工厂离职后，我又开始想，我要干什么的问题了。想过做运营，当时还挺关注一个做出租房的小程序的。终究是没有下定决心。</p><p>后面一段时间，我主要做了两件事，刷 leetcode 算法，学习 bigfrontend 上面的各种 problems。后面到了过年时间，就坐着姐夫的车回家过年了，羞愧不已，一年时间啥也没干，钱也没挣到。</p><p>2022-02-10， 元宵节前几天，我买了去广州的车票，准备去深圳找工作，毕竟深圳的岗位更多一些。在那个两百多租金的出租屋里，我做了最后的准备，直接把电商项目抄到了简历上。从头到尾学，肯定是来不及了。2-19 就去了深圳，那会深圳特别冷，那天又更好写着大雨。去了提前在高德上订的青旅，去了之后才发现，一个小小的房间里，住满了五六个人，就和宿舍一样，和宣传图差太远了。我想了又想还是退订了。另外找一家，此时我也不知道要去哪，就觉得这里不行。下了楼(那家青旅在地图上根本找不到，听了接待人的指引，去到四楼才知道又有这么个地方，真是服气)。在楼下，徘徊着的时候，一个人（xm）叫住了我，她就像功夫里面的包租婆，拿着一大串钥匙那种，问我是不是要找房子。看她的样子不像是坏人，于是答应和她上去看看，1104。应该是 30 一天，住了两周。躺在床上写面试笔记，2-18 投了几家简历基本没人理，下午前公司 hr 问我岗位介绍上的东西会不会，我说会的，她就叫我去面试了。一开始还走错地方了，好在还是按时到达了公司。基本上就是问了几句，介绍了公司的产品，然后老板就送我送到了电梯口，我也不知道这是有戏的意思，没啥感觉。晚上 hr 就打电话来说面试通过了，问薪资能不能降低一点，我说 6000 已经是最低价了。然后她就说在考虑一下。周日又打了电话，说可以，周一去上班。2-28 日开启新的上班之旅。</p><p>上班的日子还是比较清闲的，比起在工厂里面的日子，不知道好了多少倍，虽然和其他人不起来，工资还是低的可怜，但也足够我生存下来了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>人生感悟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域解决方案</title>
    <link href="/blog/2022/05/29/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2/"/>
    <url>/blog/2022/05/29/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2/</url>
    
    <content type="html"><![CDATA[<ol><li><p>最推荐的方式：<strong>反向代理</strong></p><blockquote><p>什么是反向代理呢，站在客户端的角度，代理服务器的就是反向代理。客户端不知道自己连接的是那个服务器，都有代理服务器去决定转发的规则。</p><p>反向代理有诸多好处，比如：保障服务器的安全，因为它隐藏了真正的服务器端地址；负载均衡，通过转发策略向多个服务器进行请求转发；缓存静态内容；</p><p>最常用的反向代理服务器当属 Nginx.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen              443 ssl;<br>    server_name         backend1.example.com;<br><br>    ssl_certificate     /etc/ssl/certs/server.crt;<br>    ssl_certificate_key /etc/ssl/certs/server.key;<br>    <span class="hljs-comment">#...</span><br>    location /yourapp &#123;<br>        proxy_pass http://url_to_app.com;<br>        <span class="hljs-comment">#...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p></blockquote></li><li><p>开发中使用的正向代理</p><blockquote><p>Webpack 构建的 Webpack-dev-server 插件支持代理的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devSeerver</span>: &#123;<br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-comment">// 以 /api 开头的请求会被转发到target 指定的地址</span><br>    <span class="hljs-string">&#x27;/api/&#x27;</span>: &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8090&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></blockquote></li><li><p>CORS (Cross-Origin Resource Sharing)</p><blockquote><p>这种跨域方式，将请求类型分为两种——简单请求和非简单请求，分别做出处理</p><p>浏览器发送请求的时候会在头部的 Origin 字段中带上本次的 “源” （协议+域名+端口）信息，服务器端会返回能够接受的源，“*” 表示接受任意源的请求。</p></blockquote></li><li><p>Websocket 解决跨域</p><blockquote><p>Websocket 和 HTTP 一样，也是基于 TCP 的一种网络协议，与 HTTP (HTTPS) 对应的是 WS (WSS)，对于 Websocket 没有同源限制。</p></blockquote></li><li><p>JSONP (JSON with Padding)</p><blockquote><p>虽然 AJAX 请求必须同源，但是对 样式、js资源文件的请求却可以是不同源的。</p><p>于是哦，可以通过 script 标签，向另一个服务器端请求文件时带上参数。然后，请求脚本文件后，执行脚本。脚本使用请求 url 中的参数，完成取数据的操作。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>了不起的JavaScript工程师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题（一）</title>
    <link href="/blog/2022/01/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2022/01/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>H5新特性</p><ul><li>拖拽释放（Drap and drop) API ondrop</li><li>自定义属性 data-id</li><li><strong>语义化标签，header、nav、footer、aside、article、section</strong></li><li>音频自动播放属性 autoplay</li><li>画布 Canvas</li><li>离线存储 localStorage、会话存储 sessionStorage</li><li>表单控件，calendar、date、time、email、url、search</li><li>新技术，web worker、web socket、geolocation</li></ul><p>C3新特性</p><ul><li>颜色新增，RGBA、HSLA模式</li><li>文字阴影，text-shadow</li><li>盒模型，box-sizing</li><li>渐变，linear-gradient、radial-gradient</li><li>过度，transition <code>&lt;animation-name&gt;</code></li><li>自定义动画 animate @keyframe</li><li>媒体查询，@media screen and (max-width: 800px) { … }</li><li><strong>弹性布局，flex</strong></li></ul><p>H5浏览器存储有哪些</p><ul><li><strong>cookie，在控制台输入<code>document.cookie</code> 可以看到当前页面的cookie值，是一个字符串，以分号分隔</strong>，<code>&#39;_octo=GH1.1.647075200.1634350299; tz=Etc%2FGMT-8&#39;</code>。cookie 始终在同源的 http 请求中携带。</li><li>localStorage，本地化持久存储，只要用户不删除，就一直存在。在控制台输入<code>sessionStorage </code>得到 <code>Storage &#123;length: 0&#125;</code></li><li>sessionStorage，面向session 的浏览器存储，因此只存在于一个页面的生命周期内。在控制台输入<code>localStorage</code>得到 <code>Storage &#123;ref-selector:helloqingfeng/Awsome-Front-End-learning-resource:branch: &#39;&#123;&quot;refs&quot;:[&quot;master&quot;,&quot;gh-pages&quot;],&quot;cacheKey&quot;:&quot;v0:1472661172.0&quot;&#125;&#39;, ref-selector:baozouai/shop-admin:branch: &#39;&#123;...&#125;&#39;</code></li><li>indexedDB，<code>IDBFactory &#123;&#125;</code></li><li>window对象上的全局变量</li></ul><p>盒子水平垂直居中</p><ul><li><strong>margin: 0 auto;</strong></li><li>display: table-cell;</li><li><strong>display: flex; jusitify-content: center; align-items: center;</strong></li><li>.parent { position: relative } .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)}</li></ul><p>CSS盒模型</p><ul><li>box model 指的是css 中所有元素都可以看作是一个个的盒子，包括内容、内边距、边框、外边距。</li><li>盒模型分两种<ul><li>w3c 标准盒模型，称为标准盒模型。<strong>height 属性指的是 content 内容区域的大小</strong></li><li>ie 标准盒模型，怪异盒模型。<strong>height 属性指的是 content+border+padding 的大小</strong></li></ul></li></ul><p>块级元素和行内元素的区别</p><ul><li><strong>块级元素占一行，填满父元素。可以设置 width、height、margin、padding 属性</strong></li><li>行内元素随着内容宽度变化而变化。自动换行。宽高无效，水平方向的margin、padding有效</li></ul><p>选择器权重</p><ul><li><code>!important &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器、伪类、属性 &gt; 标签、伪元素 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></li><li>权重计算方式为选择符中ID <code>选择器的数量 x 100 + 类、伪类、伪元素的数量 x 10 + 标签、伪元素的数量</code>。<strong>div#app.child[name=”appName”] 的权重值为 a=1,b=2,c=1 ➡ 1+100+10x2 = 121</strong></li></ul><p>语义化标签</p><ul><li>利用html 的原生样式减少css 样式的书写。</li><li><strong>有利于SEO ，便于浏览器理解页面结构</strong></li><li>样式丢失的时候也能呈现较为清晰的页面结构</li><li>常见的语义化标签<ul><li><code>&lt;header&gt;</code> 、<code>&lt;section&gt;</code> 、<code>&lt;article&gt;</code> 、<code>&lt;aside&gt;</code> 、<code>&lt;footer&gt;</code></li></ul></li></ul><p>H5 事件举例</p><ul><li>通过 <code>on+&lt;事件名字&gt;</code> 的形式，作为元素的属性进行指定</li><li><strong>onblur 失去焦点、onchange 元素改变、onclick 单击鼠标</strong>、onkeydown 按下按键时候触发、onkeypress 按下并松开时触发、onkeyup 松开按键时触发。</li></ul><p>H5 input 元素 type 值举例</p><ul><li>button、checkbox、<strong>color 拾色器、date 日期字段、month 定义月、time 定义时间</strong>、email、file、hidden 隐藏输入字段、image 输入图像、number 带有微调spinner 控件的字段、password、radio、search、submit、text、url</li></ul><p>css 三角形制作</p><ul><li><strong>画三角形的实质是设置内容宽高为0，显示其中一条边界线</strong>。</li><li>.triangle { width: 0; height: 0; border 50px solid transparent; border-bottom: 100px solid green;}</li></ul><p>css 中的单位，px、em、rem</p><ul><li>px 像素，绝对单位，相对于显示器屏幕分辨率而言。是计算机系统的数字化图像长度单位</li><li>em 相对于当前元素内文本的字体尺寸</li><li><strong>rem 相对于根元素的字体尺寸</strong>， html 根元素默认 16px。</li></ul><p>display: none 和 visibility： hidden 区别</p><ul><li><strong>display: none 元素隐藏，占据的空间消失</strong></li><li>visibility： hidden 元素不可见，仍然占据页面空间</li></ul><p>position 属性的值有哪些</p><ul><li>static：元素默认值</li><li><strong>relative：相对于元素原来在文档流中的定位</strong></li><li><strong>absolute：相对于最近的非 static 定位祖先元素进行定位</strong></li><li>fixed：相对于相对于屏幕视口（viewport）的位置进行定位</li><li>sticky：相对它的最近滚动祖先和最近块级祖先进行定位</li></ul><p>雪碧图</p><ul><li><strong>将网站上用到的一些图片合并到一张图片上，通过减少网络请求来提高性能</strong>。</li><li>缺点，图片位置需要精确的指定，利用background、background-position 属性，增加了css 样式的编写难度。</li></ul><p>css3 新增伪类，伪元素</p><ul><li>:first-of-type 父元素的首个p元素、:last-of-type 最后的p元素</li><li><strong>:nth-child(n) 括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3…），还有odd、even 可用</strong></li><li>:not(p) 非p元素、:enabled 表单控件的可用状态、:disabled 禁用表单控件、:checked 单选框或者复选框被选中。</li><li>::first-line 样式添加到文本的首字母，::first-line 样式添加到文本的首行。</li><li>低版本的IE中，不兼容双冒号，继续使用单冒号的伪元素。</li><li>伪元素一般指的是特殊位置，而伪类，是特殊状态</li></ul><p>图片懒加载原理</p><ul><li>核心是，监控图片位置，在合适的位置将其加载出来。</li><li>设置图片的data-set 属性，为图片的url。当图片的顶点坐标Y小于页面和浏览器高度时，将data-set 内url 属性赋值给src。涉及到的API包括obj.getBoundingClientRect().top;document.documentElement.clientHeight;</li></ul><p>JS 基本类型，引用类型</p><ul><li><strong>基本数据类型：number, string, boolean, null, undefined</strong></li><li>引用数据类型：function, object, Array</li><li>undefined 表示变量声明但是未初始化的值</li><li>null 表示准备用来保存对象，但还没有真正保存对象的值</li><li>undefined 派生至 null</li></ul><p>创建对象的几种方式</p><ul><li><strong>字面量对象， <code>let o1 = &#123; name: &#39;01&#39;&#125;</code></strong></li><li>new 一个对象，<code>let o2 = new Object(&#123; name: &#39;02&#39;&#125;)</code></li><li>显式的构造函数，<code>let o3 = function() &#123; this.name = &#39;03&#39;&#125;;</code></li><li>Object.create()，<code>let o = &#123; name: &#39;04&#39;&#125;; let o3 = Object.create(o)</code></li></ul><p>区分数组和对象</p><ul><li><strong>Array.isArray()，</strong><ul><li>Aarray.isArray([]) // true</li><li>Array.isArray({}) // false</li></ul></li><li><strong>instanceof，</strong><ul><li>[] instanceof Array // true</li><li>{} instanceof Array // false</li></ul></li><li>constructor，<ul><li>{}.constructor // 返回object</li><li>[].constructor // 返回Array</li></ul></li><li>Object.prototype.toString.call()，<ul><li>Object.prototype.toString.call([]) //[“object Array”]</li><li>Object.prototype.toString.call({}) // [“object Object”]</li></ul></li></ul><p>伪数组（类数组）转化</p><ul><li>伪数组具有length 属性，以及按照数组索引的方式存储数据。</li><li>转化方式<ul><li><strong>Array.from()</strong></li><li><strong>[].slice.call(eleArr) 或者 Array.prototype.slice.call(eleArr)</strong></li></ul></li></ul><p>遍历对象属性</p><ul><li>Object.keys() 可枚举，非继承属性。for…in 还包括继承的可枚举属性</li><li>Object.getOwnPropertyNames() 可枚举，不可枚举，非继承属性</li><li><strong>hasOwnProperty() 判断对象是否有某个属性</strong></li></ul><p>src 和 href 区别</p><ul><li>src (source) 资源，指向的内容会嵌入到标签所在位置，比如脚本，图片，iframe。解析到此类元素时。<strong>浏览器会暂停其他元素的下载和处理</strong>。知道将该元素加载、编译、执行完毕。</li><li>href (hypertext reference) 建立和当前元素的链接。会并行下载i资源，不会停止对当前文档的处理。</li></ul><p>dom 事件模型</p><ul><li><strong>元素发生一个事件，父元素也感受到了。那么就有了一个先后执行的问题。</strong></li><li>事件由根元素开始触发，向内传播 —— 事件捕获</li><li>事件由目标元素，一直传播到根元素 —— 事件冒泡</li><li>addEventListener 默认为事件冒泡机制</li><li>可以用 e.stopPropagation(); 或者 return false; 或者 e.preventDefault(); 停止事件在冒泡链上进一步扩大</li></ul><p>js 定时器</p><ul><li>setTimeout() —— 在指定毫秒数后运行函数，一般用来模拟异步操作。</li><li>setInterval() —— 按照设置的时间间隔运行函数，<strong>直到 clearInterval() 或者窗口被关闭</strong></li></ul><p>回调函数</p><ul><li>软件模块之间的接口，从调用方式上可以分为 3 类，<strong>同步调用、异步调用、回调</strong></li><li>同步调用就是通常所说的调用函数，一步一步执行，这是一种阻塞式调用，函数执行完毕才会返回。</li><li>异步调用，是一种类似于消息或者事件的机制。接口的服务在收到某种讯息或发生某种事件的时候，主动通知调用方。</li><li>回调函数就是一个通过函数指针调用的函数。把函数指针（地址）作为函数参数传递给另一个函数。</li></ul><p>什么是闭包</p><ul><li>闭包，closure，可以理解为一个封闭空间，一个定义在函数内部的函数。<strong>它可以通过作用域链访问外部函数的变量空间</strong>。</li><li>可以利用闭包的这个性质，保存外部变量，当然也会造成一些性能损失。</li></ul><p>原型的理解</p><ul><li>原型的作用是为了<strong>实现继承，和扩展对象的一种代码重用机制</strong>。</li><li>js 中的所有元素，都可以看作是对象，他们都有一个 prototype 属性，它的值是一个对象，叫做原型，这个prototype 属性又有自己的 prototype 属性。最终链接到 Object 对象。</li><li>prototype 属性，有一个 constructor 属性。可以用来构造对象的实例。</li></ul><p>说下 this</p><ul><li>this 是一个标识符，<strong>用来指代函数执行的上下文执行环境</strong>。</li><li>讲 this，就一定要说一下对象的构造机制。在构造对象的时候，this 赋值为一个Object 实例，然后向其中添加属性方法。那么，对这个对象内部的函数，this 可以在它的变量表中，找到 this 所指代的对象。</li><li>那么一般地调用对象内部的方法，this 就是 函数前面的对象。从对象可以找到函数，那么函数内部的this, 指的就是这个对象。</li><li>另一个函数回调，要通过apply、call 手动声明函数的执行上下文，this 指代的是什么。</li><li>箭头函数，没有自己的this, 它使用的是自己定义环境中的this 指代的对象。通过作用域链是使用this。</li></ul><p>统计出现最多的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 先定义一个空对象,稍后使用.</span><br><span class="hljs-keyword">var</span> maxChar=<span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 要输出的字符</span><br><span class="hljs-keyword">var</span> maxN=<span class="hljs-number">0</span>;<span class="hljs-comment">// 字符数量</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123; <span class="hljs-comment">//   循环字符串中每一项</span><br>    <span class="hljs-keyword">var</span> k = str[i]; <span class="hljs-comment">// 把每一项保存给变量 k (对这一步不理解可先熟悉 for循环机制);</span><br><br>    <span class="hljs-keyword">if</span> (obj[k]) &#123;<br><br>        obj[k]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        obj[k] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(obj[k]&gt;maxN)&#123;<br>        maxChar=k;<br>        maxN=obj[maxChar];<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(maxChar, maxN);<br></code></pre></td></tr></table></figure><p>内存泄漏</p><ul><li>一些不再使用的变量，依然占据着内存空间，称为内存泄漏，（浪费掉了）</li></ul><p>事件循环</p><ul><li>js 是一个单线程的语言。这意味着同一时间只能做一件事。</li><li>单线程不意味着阻塞，<strong>实现单线程非阻塞的方法是事件循环</strong>。</li><li>js 中的任务可以分为同步任务和异步任务<ul><li>同步任务就是立即执行的任务，会直接进入到主线程中执行</li><li>异步任务，异步执行的任务，比如ajax网络请求，setTimeout 定时函数</li><li>同步任务执行完毕，就会去任务队列中的任务，推入主线程执行。</li></ul></li><li>异步任务又分为宏任务和微任务<ul><li>执行机制为执行完宏任务后，执行所有微任务。再进行查看是有宏任务</li><li>常见的微任务有，Promise.then，MutationObserver，process.nextTick</li></ul></li></ul><p>Promise</p><ul><li>promise 是一个有状态的对象</li><li>将异步操作的结果和对应的处理函数结合起来</li><li>将异步操作以同步操作的流程表达出来，避免回调地狱</li><li>Promise 的构造函数接收一个回调，回调有两个参数 <code>resolve reject</code>，成功就调用resolve，表示promise 状态fulled，结果为resolve 返回的结果。实例化的Promise，返回的对象可以调用 then()  方法，then()  方法接收两个参数，onResolve 和 onReject 对应promise 成功或者失败的状态</li></ul><p>手写 Promise</p><ul><li><p>```js<br>class Promise {</p><pre><code class="hljs">constructor(handler) &#123;    // define initial state    this.status = &quot;pending&quot;;    this.onFulfilledCallbacks = [];    this.onRejectedCallbacks = [];        // define basic transition function    const resolve = value =&gt; &#123;        if (this.status === &quot;pending&quot;) &#123;            this.status = &quot;fulfilled&quot;;            this.value = value;            this.onFulfilledCallbacks.forEach(fn =&gt; fn(value));        &#125;    &#125;;    const reject = value =&gt; &#123;        if (this.status === &quot;pending&quot;) &#123;            this.status = &quot;rejected&quot;;            this.value = value;            this.onRejectedCallbacks.forEach(fn =&gt; fn(value));        &#125;    &#125;;    try &#123;        // call outer function passed in        handler(resolve, reject);    &#125; catch (err) &#123;        reject(err);    &#125;&#125;then(onFulfilled, onRejected) &#123;    // support chain call    return new Promise((resolve, reject) =&gt; &#123;        // define handler        if (this.status === &quot;pending&quot;) &#123;            this.onFulfilledCallbacks.push(() =&gt; &#123;                try &#123;                    // if return value is promise, resolve it.                    const fulfilledFromLastPromise = onFulfilled(this.value);                    if (fulfilledFromLastPromise instanceof Promise) &#123;                        fulfilledFromLastPromise.then(resolve, reject);                    &#125; else &#123;                        resolve(fulfilledFromLastPromise);                    &#125;                &#125; catch (err) &#123;                    reject(err);                &#125;            &#125;);            this.onRejectedCallbacks.push(() =&gt; &#123;                try &#123;                    const rejectedFromLastPromise = onRejected(this.value);                    if (rejectedFromLastPromise instanceof Promise) &#123;                        rejectedFromLastPromise.then(resolve, reject);                    &#125; else &#123;                        reject(rejectedFromLastPromise);                    &#125;                &#125; catch (err) &#123;                    reject(err);                &#125;            &#125;);        &#125;        if (this.status === &quot;fulfilled&quot;) &#123;            try &#123;                const fulfilledFromLastPromise = onFulfilled(this.value);                if (fulfilledFromLastPromise instanceof Promise) &#123;                    fulfilledFromLastPromise.then(resolve, reject);                &#125; else &#123;                    resolve(fulfilledFromLastPromise);                &#125;            &#125; catch (err) &#123;                reject(err);            &#125;        &#125;        if (this.status === &quot;rejected&quot;) &#123;            try &#123;                const rejectedFromLastPromise = onRejected(this.value);                if (rejectedFromLastPromise instanceof Promise) &#123;                    rejectedFromLastPromise.then(resolve, reject);                &#125; else &#123;                    reject(rejectedFromLastPromise);                &#125;            &#125; catch (err) &#123;                reject(err);            &#125;        &#125;    &#125;);&#125;</code></pre><p>}</p><p>// testing code<br>let p1 = new Promise((resolve, reject) =&gt; {</p><pre><code class="hljs">setTimeout(() =&gt; resolve(&#39;resolved first one&#39;), 1000);</code></pre><p>});<br>p1.then((res) =&gt; {</p><pre><code class="hljs">console.log(res);return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; resolve(&#39;resolved second one&#39;), 1000);&#125;);</code></pre><p>}).then(res =&gt; {</p><pre><code class="hljs">console.log(res);</code></pre><p>});</p><p>// 1 sec later, ‘resolved first one’<br>// 1 sec later, ‘resolved second one’</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>实现 <span class="hljs-built_in">Promise</span>.all, <span class="hljs-built_in">Promise</span>.race, <span class="hljs-built_in">Promise</span>.resolve <span class="hljs-keyword">and</span> <span class="hljs-built_in">Promise</span>.reject<br><br>- ```<span class="language-javascript">js</span><br><span class="language-javascript">  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">          <span class="hljs-keyword">const</span> result = [];</span><br><span class="language-javascript">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">              <span class="hljs-comment">// resolve revery promise, return result when every resolved</span></span><br><span class="language-javascript">              <span class="hljs-comment">// when reject, return reject(err)</span></span><br><span class="language-javascript">              <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">                  result[i] = res;</span><br><span class="language-javascript">                  counter += <span class="hljs-number">1</span>;</span><br><span class="language-javascript">                  <span class="hljs-comment">// this check need to be here, otherwise counter would remain 0 till forloop is done</span></span><br><span class="language-javascript">                  <span class="hljs-keyword">if</span> (counter === promises.<span class="hljs-property">length</span>) &#123;</span><br><span class="language-javascript">                      <span class="hljs-title function_">resolve</span>(result);</span><br><span class="language-javascript">                  &#125;</span><br><span class="language-javascript">              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;</span><br><span class="language-javascript">                  <span class="hljs-title function_">reject</span>(err);</span><br><span class="language-javascript">              &#125;);</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> newPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-comment">// after 100ms, output:  Array [3, 42, &quot;foo&quot;]</span></span><br></code></pre></td></tr></table></figure></li><li><p>```js<br>Promise.race = function (promises) {</p><pre><code class="hljs">return new Promise((resolve, reject) =&gt; &#123;    for (let p of promises) &#123;        // iterate every promise, return the first one        Promise.resolve(p).then(res =&gt; resolve(res), err =&gt; reject(err));    &#125;&#125;);</code></pre><p>}</p><p>// testing<br>const promise1 = new Promise((resolve, reject) =&gt; {</p><pre><code class="hljs">setTimeout(resolve, 500, &#39;one&#39;);</code></pre><p>});<br>const promise2 = new Promise((resolve, reject) =&gt; {</p><pre><code class="hljs">setTimeout(resolve, 100, &#39;two&#39;);</code></pre><p>});<br>Promise.race([promise1, promise2]).then((value) =&gt; {</p><pre><code class="hljs">console.log(value);// Both resolve, but promise2 is faster</code></pre><p>}, err =&gt; console.log(err));<br>// expected output: “two”</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>- ```<span class="language-javascript">js</span><br><span class="language-javascript">  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> value;</span><br><span class="language-javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">resolve</span>(value);</span><br><span class="language-javascript">          &#125;);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(reason));</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve1</span>(<span class="hljs-string">&quot;Success&quot;</span>);</span><br><span class="language-javascript">  p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// &quot;Success&quot;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject1</span>(<span class="hljs-string">&quot;No&quot;</span>); </span><br><span class="language-javascript">  p2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123; &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)); <span class="hljs-comment">// &quot;No&quot;</span></span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express Middleware 的简易实现</title>
    <link href="/blog/2022/01/09/express-middleware%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <url>/blog/2022/01/09/express-middleware%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://programmer.ink/think/simple-implementation-principle-of-express-middleware.html">Simple implementation principle of Express Middleware</a></p><p>简而言之，express 中间件，就是在服务器端处理<strong>请求对象</strong>和<strong>响应对象</strong>的函数。</p><p>遵循一个先注册，先执行的原则，通过调用<code>next()</code>函数，把执行权交给下一个函数。</p><p>核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> stack = stacks.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-keyword">if</span>(stack) &#123;<br>        <span class="hljs-title function_">stack</span>(req, res, next);<br>    &#125;<br>&#125;<br><span class="hljs-title function_">next</span>();<br></code></pre></td></tr></table></figure><p>express 简易实现的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> slice = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span><br><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Express</span> &#123;<br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = &#123;<br>            <span class="hljs-attr">all</span>: [], <span class="hljs-comment">// Match all middleware functions</span><br>            <span class="hljs-attr">get</span>: [],<br>            <span class="hljs-attr">post</span>: []<br>        &#125;<br>     &#125;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Integrate middleware here</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; path </span><br><span class="hljs-comment">      * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">object</span>&#125;</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-title function_">middlewareHandler</span>(<span class="hljs-params">path</span>) &#123;<br>        <span class="hljs-keyword">const</span> info = &#123;&#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> path === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-comment">// by use()、get()、post()、pass into &lt;path&gt; and &lt;handler&gt;</span><br>            <span class="hljs-comment">// 如果包含路劲参数，那么第二个参数开始才是中间件函数</span><br>            info.<span class="hljs-property">path</span> = path<br>            info.<span class="hljs-property">stack</span> = slice.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// Middleware array</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 只传进去中间件函数，那么全部是handler.</span><br>            info.<span class="hljs-property">path</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>            info.<span class="hljs-property">stack</span> = slice.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">0</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> info<br>     &#125;<br><br>     <span class="hljs-title function_">use</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> allStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">middlewareHandler</span>(...<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">all</span>.<span class="hljs-title function_">push</span>(allStack)<br>     &#125;<br><br>     <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> getStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">middlewareHandler</span>(...<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">get</span>.<span class="hljs-title function_">push</span>(getStack)<br>     &#125;<br><br>     <span class="hljs-title function_">post</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> postStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">middlewareHandler</span>(...<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">post</span>.<span class="hljs-title function_">push</span>(postStack)<br>     &#125;<br><span class="hljs-comment">// 通过按照 方法 分类，建立 路径 到 处理函数 的映射</span><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * </span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; method </span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">url</span></span><br><span class="hljs-comment">       * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Array</span>&#125; </span><br><span class="hljs-comment">       */</span><br>     <span class="hljs-title function_">accordStack</span>(<span class="hljs-params">method, url</span>) &#123;<br>        <span class="hljs-keyword">let</span> stacks = []<br>        stacks = stacks.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">all</span>)<br>        stacks = stacks.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>[method])<br>        <span class="hljs-keyword">return</span> stacks<br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">stack</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> url.<span class="hljs-title function_">indexOf</span>(stack.<span class="hljs-property">path</span>) !== -<span class="hljs-number">1</span><br>        &#125;).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">stack</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 这里有点问题，不应该只传进去第一个handler.</span><br>     &#125;<br><br>     <span class="hljs-title function_">handler</span>(<span class="hljs-params">req, res, stacks</span>) &#123;<br>         <span class="hljs-comment">// Function expression</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-keyword">const</span> stack = stacks.<span class="hljs-title function_">shift</span>()<br>            <span class="hljs-keyword">if</span>(stack) &#123;<br>                <span class="hljs-title function_">stack</span>(req, res, next)<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_">next</span>()<br>     &#125;<br><br>     <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>            res.<span class="hljs-property">json</span> = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>                res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>)<br>                res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data))<br>            &#125;<br>            <br>            <span class="hljs-comment">// Get the request method and url, and filter the middleware functions</span><br>            <span class="hljs-keyword">const</span> &#123;method, url&#125; = req<br>            <span class="hljs-keyword">const</span> stacks = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">accordStack</span>(method.<span class="hljs-title function_">toLowerCase</span>(), url)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handler</span>(req, res, stacks)<br>        &#125; <br>     &#125;<br><br>     <span class="hljs-title function_">listen</span>(<span class="hljs-params">...args</span>) &#123;<br>         <span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>())<br>         server.<span class="hljs-title function_">listen</span>(...args)<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// Factory mode, export an instance object</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Express</span>()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>require 是什么</title>
    <link href="/blog/2022/01/09/require-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/blog/2022/01/09/require-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://nodejs.org/en/knowledge/getting-started/what-is-require/">What is require?</a></p><p>Nodejs 遵循 CommonJS 模块系统规则，内置的<code>require</code> 函数，是引入模块最简单的方法。<code>require</code> 基础功能是读取 Javascript 文件，执行文件，然后返回<code>exports</code> 对象。例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;evaluating example.js&quot;</span>);<br><br><span class="hljs-keyword">var</span> invisible = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;invisible&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;hi&quot;</span>;<br><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>.<span class="hljs-property">message</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果运行 <code>let example = require(&#39;./example.js&#39;)</code> , example.js 被计算求值，example 等于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hi&quot;</span>,<br>  <span class="hljs-attr">say</span>: [<span class="hljs-title class_">Function</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要将 <code>exports</code> 对象设置为函数或新对象，则必须使用 <code>module.exports</code> 对象。举个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./example2.js&#x27;</span>)() <span class="hljs-comment">//require itself and run the exports object</span><br></code></pre></td></tr></table></figure><p>值得注意的是，每当您随后需要一个已经需要的文件时，导出对象都会被缓存并重用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>)<br>evaluating example.js<br>&#123; message: <span class="hljs-string">&#x27;hi&#x27;</span>, say: [Function] &#125;<br>node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>)<br>&#123; message: <span class="hljs-string">&#x27;hi&#x27;</span>, say: [Function] &#125;<br>node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>).message = <span class="hljs-string">&quot;hey&quot;</span> //set the message to <span class="hljs-string">&quot;hey&quot;</span><br><span class="hljs-string">&#x27;hey&#x27;</span><br>node&gt; require(<span class="hljs-string">&#x27;./example.js&#x27;</span>) //One might think that this <span class="hljs-string">&quot;reloads&quot;</span> the file...<br>&#123; message: <span class="hljs-string">&#x27;hey&#x27;</span>, say: [Function] &#125; //...but the message is still <span class="hljs-string">&quot;hey&quot;</span> because of the module cache.<br></code></pre></td></tr></table></figure><p>从上面可以看到，example.js 是第一次计算的，但是所有后续调用都只需要调用模块缓存，而不是再次读取文件。如上所述，这偶尔会产生副作用。</p><p>require 查找文件的规则可能有点复杂，但一个简单的经验法则是，如果文件不以 “./“ 或 “/“，那么它要么被视为核心模块(并检查本地 Node.js 路径) ，要么被视为本地 node _ modules 文件夹中的依赖项。如果文件以 “./“  开头。它被认为是调用 require 的文件的相对文件。如果文件以 “/“ 开头，则认为它是绝对路径。注意: 你可以省略 “.js” 。如果需要的话，会自动添加。有关更多详细信息，请参阅官方文档。</p><p>另外需要注意的是：如果传递的文件名实际上是一个目录，那么它将首先在目录中查找 package.json 并加载 main 属性中引用的文件。否则，它将查找 index.js。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipconfig 信息解读</title>
    <link href="/blog/2021/12/29/ipconfig-%E4%BF%A1%E6%81%AF%E8%A7%A3%E8%AF%BB/"/>
    <url>/blog/2021/12/29/ipconfig-%E4%BF%A1%E6%81%AF%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>因为有手机端调试网页的需求，于是找了一下手机端如何连接PC 端服务器方法。</p><p>之前解决过一次，因为没弄清楚原理，现在又忘了。</p><p>解决方案是：手机端浏览器地址栏输入<strong>无线网适配器的IPv4地址</strong>，对应的文件名也需要输入。</p><p>具体原理如下：</p><p>打开 <code>cmd</code> 命令行提示符窗口，</p><p>运行 <code>ipconfig</code>， 得到网络连接的相关信息。<code>ipconfig /all</code> 可以看到更加详细的信息。</p><p>首先了解一个概念，计算机是通过网卡，这个硬件来跟计算机网络系统来进行通讯的。网卡，又叫适配器，有一个类似于身份证一样的东西，唯一标识符，叫做<strong>物理地址：12个十六进制数，正好48位</strong>。</p><p>那么在PC 端所在的局域网中，每一个网络终端都会有一个IPv4 地址，用来进行通讯，数据的发送与接收。这个地址就是网卡和别的网卡进行通讯的标识符。手机与电脑通过WiFi 进行交互，也就是访问电脑端的<strong>无线网卡IPv4地址</strong>。</p><p>同理可得，以太网适配器中的IPv4 地址，就是和路由器网关进行通讯的标识符。</p><p>关于子网掩码：<a href="https://www.zhihu.com/question/56895036">如何理解子网掩码？</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思考学习方法</title>
    <link href="/blog/2021/12/28/%E6%80%9D%E8%80%83%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/12/28/%E6%80%9D%E8%80%83%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>为什么读那么多理论教程，不如实际操作一番，来得更加印象深刻呢？</p><p>因为现实世界是复杂的，语言文字对事物的描述，是对事物的一个基本面的快照，很难让你构建起一个事物的框架。于是所学过的知识点，便成了碎片信息，不便于存储利用。</p><p>大脑不擅长记忆存储信息，而擅长观察事物之间的联系。所以，知识点，如果不能形成一个良好检索的结构，比如树形，拓扑形，那么在需要检索它的时候，便会遇到很多阻碍，“记不住” 的现象也就随之发生了。</p><p>所以，符合大脑记忆规律的学习方法就是，理论和实践相结合。</p><p>话说了很多遍了，但还是要重复一次。</p><p>先理论，获取认知的基础点。比如 ts 是什么，解决了什么样的问题？</p><p>再实践，搭建起整体的架构。比如，在算法题中使用 ts, 做一下类型体操</p><p>紧接着，基于实践中的需要，开发具体的项目…</p><p>深入理论的学习，类型理论，自动推导…</p><p>在理论的扩展中，扩大实践活动。高手进阶之路</p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 全链路分析</title>
    <link href="/blog/2021/12/28/git-%E5%85%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <url>/blog/2021/12/28/git-%E5%85%A8%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本文将对 git 的日常使用，做一个全链路的分析，结合文档，做一个细致描述。</p><p>首先，在脑海中，准备基础概念：</p><p>在自己电脑上的环境称为<code>local</code> 本地环境，<code>remote repo</code> 远程仓库 是在github的服务器上。</p><p>本地环境又有三个位置：分别是 <code>工作目录</code> 又被称为工作区、工作树，<code>暂存区</code> 又被称为索引区，<code>本地仓库</code>。</p><p>了解基本概念后，开始进行操作，注意 git 是一个分布式版本控制系统，一切都为追踪管理文件而生。</p><p><img src="https://user-images.githubusercontent.com/43318823/147582097-e2acd0db-2fa5-43b2-9223-c0edda81030f.png"></p><p>当我们初始化一个 git 仓库后，也就开启了 git 使用之旅。</p><p><code>git init</code> 创建一个 git 仓库，或者重新初始化一个已存在的仓库。想象一下，你有一个仓库，有货物没货物，你都可以派一个<strong>仓库管理员</strong>去管理它。</p><p>当你对本地目录做了一些操作之后，比如增加文件、删除文件、给文件增加内容、删减内容，此时，你可以用<code>git add &lt;file&gt;</code> 来将操作的内容保存为一个快照（不管干了啥，通通看作是一个对象obj，有个标志符可以让你操作它），进行<strong>追踪 track，也叫做 staged</strong>。 一般地，可以使用 <code>git add .</code> 或者 <code>git add -A</code> 进行全部更改的追踪。</p><p>现在你可以用 <code>git status</code> 来查看追踪的状态。(使用<code>git restore --staged &lt;file&gt;...</code> 取消追踪)</p><p>接下来，就可以进行提交操作，提交到本地仓库中去。使用的命令是<code>git commit -m &lt;msg&gt;</code> msg 的内容为log 信息，必须要写的。</p><p>git add 和 git commit 的操作，合并了就是 <code>git commit -am &lt;msg&gt;</code></p><p>现在，目光来到本地仓库。</p><p><code>git push</code> 将本地仓库的提交，推送到远程仓库。第一次推送，要指明仓库名和分支 <code>git push &lt;remote&gt; &lt;branch&gt;</code></p><p>完成从本地到远程的操作后，来看一下从远程到本地仓库的操作。</p><p><code>git clone</code> 将远程仓库，克隆到本地目录。</p><p><code>git pull</code> 获取远程仓库的更新，是<code>git push</code> 的逆向操作。</p><p>以上就是git 的日常使用命令。<code>git init</code> 初始化建仓库; <code>git commit -am &lt;msg&gt;</code> 提交到本地仓库; <code>git push</code>推送到远程仓库；</p><p><code>git pull</code> 从远程仓库拉取更新，是<code>git push</code> 的逆向操作；<code>git clone</code> 下载一个仓库到本地；</p><p>总之，要把每次对文件的操作看作是一个整体，进行相关操作。具体需要用到的命令也可以现用现查。</p><p>进一步学习：</p><ul><li><a href="https://ndpsoftware.com/git-cheatsheet.html#loc=index;">git 可视化工具</a></li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a></li><li><a href="https://onlywei.github.io/explain-git-with-d3">Explain Git With D3</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html未占满全屏</title>
    <link href="/blog/2021/12/28/html%E6%9C%AA%E5%8D%A0%E6%BB%A1%E5%85%A8%E5%B1%8F/"/>
    <url>/blog/2021/12/28/html%E6%9C%AA%E5%8D%A0%E6%BB%A1%E5%85%A8%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<p>解决 html, body 元素未占满全屏的问题</p><p>设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后，并没有解决问题。</p><p>因为浏览器默认按照窗口大小（viewport）来设置 html 元素大小。于是，当页面缩小的时候，html 变小，但是页面元素的尺寸是写死的，于是越界，侧边出现白边。</p><p>解决办法是设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;<br><span class="hljs-attribute">min-width</span>: <span class="hljs-number">1400px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是设置最小宽度，使得 html 元素包含内部元素。不随着窗口大小改变到最小值以下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>bug fix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法——生成独一无二的标识符</title>
    <link href="/blog/2021/12/16/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    <url>/blog/2021/12/16/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="153-uglify-CSS-class-names"><a href="#153-uglify-CSS-class-names" class="headerlink" title="153. uglify CSS class names"></a>153. uglify CSS class names</h1><p>如果你在项目中使用了<a href="https://github.com/webpack-contrib/css-loader">css-loader</a>， 你可以像这样通过<code>localIdentName</code>来变换class name。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">localIdentName</span>: <span class="hljs-string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>,<br></code></pre></td></tr></table></figure><p>你也可以传入自定义的<code>getLocalIdent</code>函数来自由生成class name。</p><p><strong>请完成一个class name生成函数</strong> 并满足以下要求</p><ol><li>仅使用字母: <code>a</code> - <code>z</code> , <code>A</code> - <code>Z</code></li><li>调用一次返回一个类名</li><li>返回的类名序列需要满足: 先短后长，相同长度按照字母排序（小写字母优先）</li><li>同时提供一个reset函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;a&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;b&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;c&#x27;</span><br><br><span class="hljs-comment">// skip cases till &#x27;Y&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;Z&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aa&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;ab&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;ac&#x27;</span><br><br><span class="hljs-comment">// skip more cases</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;ZZ&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aaa&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aab&#x27;</span><br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;aac&#x27;</span><br><br>getUniqueClassName.<span class="hljs-title function_">reset</span>()<br><br><span class="hljs-title function_">getUniqueClassName</span>()<br><span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> chars = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUniqueClassName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> className = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> num = id++;<br>  <span class="hljs-keyword">while</span>(num &gt;= <span class="hljs-number">0</span>) &#123;<br>    className = chars[num % chars.<span class="hljs-property">length</span>] + className; <span class="hljs-comment">// 通过余数获取当前字符， 理解为52进制转为十进制</span><br>    num = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(num / chars.<span class="hljs-property">length</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 长短</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> className;<br>&#125;<br><br>getUniqueClassName.<span class="hljs-property">reset</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  id = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>package.json 文件中的软件包版本</title>
    <link href="/blog/2021/11/27/package-json-%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%89%88%E6%9C%AC/"/>
    <url>/blog/2021/11/27/package-json-%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://semver.org/lang/zh-CN/">语义化版本 2.0.0</a></p><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ol><li>主版本号：当你做了<strong>不兼容的 API 修改</strong>，</li><li>次版本号：当你做了<strong>向下兼容的功能性新增</strong>，</li><li>修订号：当你做了<strong>向下兼容的问题修正</strong>。</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><p><a href="https://www.jianshu.com/p/6061186a2733">package.json中版本号详解~和^和*的区别</a></p><ol><li><code>~</code> 匹配<strong>最新的次版本号</strong>(不包括)，**~1.15.2 :=  &gt;=1.15.2 &lt;1.16.0**   </li><li><code>^</code> 匹配<strong>最新的主版本号</strong>(不包括)，<strong>^3.3.4 := &gt;=3.3.4 &lt;4.0.0</strong></li><li><code>*</code> 匹配<strong>最新版本</strong>即可</li></ol><blockquote><p>所以建议使用~来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复。</p><p>或者版本号写*，这意味着安装最新版本的依赖包，但缺点同上，可能会造成版本不兼容，慎用！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm命令行参数</title>
    <link href="/blog/2021/11/25/npm%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <url>/blog/2021/11/25/npm%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.npmjs.com/">npm Docs</a></p><p>本文将介绍 <code>npm CLI</code> 即 npm 命令行 常用操作参数的含义，给他们做一个汇总。</p><p>概要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm &lt;<span class="hljs-built_in">command</span>&gt; [args]<br></code></pre></td></tr></table></figure><h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><p><code>npm iniy &lt;iniyializer&gt;</code> 用来初始化一个npm 包。</p><p>e.g. 创建一个 esm 兼容的包，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> my-esm-lib &amp;&amp; <span class="hljs-built_in">cd</span> my-esm-lib<br>$ npm init esm --<span class="hljs-built_in">yes</span><br><span class="hljs-comment"># 使用 -y 或者 --yes 跳过所有提问</span><br></code></pre></td></tr></table></figure><h2 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h2><p><code>npm install</code> 用来安装包所依赖的包，</p><p>默认安装 package.json 里的依赖，如果包内有 packa-lock.json 或者 npm-shrinkwrap.json, yarn.lock 文件，则安装上述文件所指明的依赖。</p><p>使用 <code>-g</code> 或者 <code>--global</code>, 指明安装的包的上下文环境为全局环境。</p><p>设置 <code>--production</code> 标志或者 <code>NODE_ENV</code> 环境变量为 <code>production</code> , npm 将不会安装在 <code>devDependencies</code> 中列出的包。可以设置 <code>--production=false</code> 否掉生产环境，使得npm 安装 <code>dependencies</code> 和 <code>devDependcies</code> 内的包。</p><p><strong><code>-P， --save-prod</code> 包将默认出现在 <code>dependencies</code> 中。</strong></p><p><strong><code>-D，--save-dev</code> 包将出现在 <code>devDependencies</code> 中</strong></p><p><code>-O， --save-optional</code> 包将出现在 <code>optionalDepencies</code> 中</p><p><code>--no-save</code> 包不出现在 <code>dependcies</code> 中</p><h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p><code>npm exec -- &lt;pkg&gt;[@&lt;version&gt;] [args...]</code> 运行本地或者远程的包</p>]]></content>
    
    
    
    <tags>
      
      <tag>文档摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6模块中的export 与import</title>
    <link href="/blog/2021/11/18/ES6%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84export-%E4%B8%8Eimport/"/>
    <url>/blog/2021/11/18/ES6%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84export-%E4%B8%8Eimport/</url>
    
    <content type="html"><![CDATA[<p>细说ES6模块中的export 与import。</p><ol><li><p>导出语句必须在模块顶级，不能嵌套在某个块中（import 同理）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 允许</span><br><span class="hljs-keyword">export</span> ... <br><span class="hljs-comment">// 不允许</span><br><span class="hljs-keyword">if</span> (condition) &#123; <br> <span class="hljs-keyword">export</span> ... <br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>命名导出 模块就好像是被导出的值的容器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 允许</span><br><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><span class="hljs-keyword">export</span> &#123; foo &#125;; <br><br><span class="hljs-comment">// 允许</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><br><span class="hljs-comment">// 允许，但应该避免</span><br><span class="hljs-keyword">export</span> &#123; foo &#125;; <br><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br></code></pre></td></tr></table></figure></li><li><p>别名必须在export 子句的大括号语法中指定（import 同理）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> myFoo &#125;;<br></code></pre></td></tr></table></figure></li><li><p>ES6 模块系统会识别作为别名提供的 default 关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <br><br><span class="hljs-comment">// 等同于 export default foo; </span><br><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;; <br></code></pre></td></tr></table></figure></li><li><p>正确示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 命名行内导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> baz = <span class="hljs-string">&#x27;baz&#x27;</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>, bar = <span class="hljs-string">&#x27;bar&#x27;</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;&#125;  <span class="hljs-comment">// 一边声明就一边导出了</span><br><br><span class="hljs-comment">// 命名子句导出</span><br><span class="hljs-keyword">export</span> &#123; foo &#125;; <br><span class="hljs-keyword">export</span> &#123; foo, bar &#125;; <br><span class="hljs-keyword">export</span> &#123; foo <span class="hljs-keyword">as</span> myFoo, bar &#125;;  <span class="hljs-comment">// 给它加个容器，反正都是要加进来的</span><br><br><span class="hljs-comment">// 默认导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;foo&#x27;</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">123</span>; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> /[a-z]*/; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;; <br><span class="hljs-keyword">export</span> &#123; foo, bar <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>*() &#123;&#125; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> &#123;&#125;  <span class="hljs-comment">// 记住别名在子句，默认不行内，一个模块一个默认导出</span><br></code></pre></td></tr></table></figure></li><li><p>禁止项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 会导致错误的不同形式：</span><br><br><span class="hljs-comment">// 行内默认导出中不能出现变量声明</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;  <span class="hljs-comment">// 关键字太多，解释器受不了😫</span><br><br><span class="hljs-comment">// 只有标识符可以出现在 export 子句中</span><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-number">123</span> <span class="hljs-keyword">as</span> foo &#125;<br><br><span class="hljs-comment">// 别名只能在 export 子句中出现</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">as</span> myFoo; <span class="hljs-comment">// 过于奇怪，解释器不想理你</span><br></code></pre></td></tr></table></figure></li></ol><p>总结一下就是：</p><ul><li>可以在声明时候导出，或者默认导出</li><li>可以把标识符放到括号里，可以在括号也就是子语句里面起别名</li></ul><hr><ol><li><p>与 export 类似，import 必须出现在 模块的顶级</p></li><li><p>命名导出可以使用 <code>*</code> 批量获取并赋值给保存导 出集合的别名，而无须列出每个标识符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>, bar = <span class="hljs-string">&#x27;bar&#x27;</span>, baz = <span class="hljs-string">&#x27;baz&#x27;</span>; <br><span class="hljs-keyword">export</span> &#123; foo, bar, baz &#125; <br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>;  <span class="hljs-comment">// * 代表整个导出的对象</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">foo</span>); <span class="hljs-comment">// foo </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">bar</span>); <span class="hljs-comment">// bar </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property">baz</span>); <span class="hljs-comment">// baz</span><br></code></pre></td></tr></table></figure></li><li><p>如果模块同时导出了命名导出和默认导出，则可以在 import 语句中同时取得它们。可以依次列出 特定导出的标识符来取得，也可以使用*来取得</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo, &#123; bar, baz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>; <br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo, bar, baz &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>; <br><br><span class="hljs-keyword">import</span> foo, * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span>; <span class="hljs-comment">// 除默认导出外。其它的导出打包到 *</span><br></code></pre></td></tr></table></figure></li></ol><p>总结一下就是：</p><ul><li>默认导出，不加花括号，也就是说不用解构赋值</li><li>在括号中，可以起别名，可以<code>default as xx</code> 正如在导出时 <code>xx as default</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(五)</title>
    <link href="/blog/2021/10/23/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%BA%94/"/>
    <url>/blog/2021/10/23/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="29-实现async-helper-sequence"><a href="#29-实现async-helper-sequence" class="headerlink" title="29. 实现async helper - sequence()"></a>29. 实现async helper - sequence()</h1><p>该题目和<a href="https://bigfrontend.dev/zh/problem/what-is-composition-create-a-pipe">11. 什么是Composition?实现pipe()</a>有些类似。</p><p>请实现一个async helper - <code>sequence()</code>。<code>sequence()</code>像<code>pipe()</code> 那样将异步函数串联在一起。</p><p>本题目中的所有异步函数是如下interface。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AsyncFunc</span> = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">   callback: Callback,</span></span><br><span class="hljs-params"><span class="hljs-function">   data: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>你的<code>sequence()</code>需要能接受一个<strong>AsyncFunc 数组</strong>，并且通过callback将之串联在一起。</p><p>假设我们有一个异步函数把数字乘以2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncTimes2</span> = (<span class="hljs-params">callback, num</span>) =&gt; &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, num * <span class="hljs-number">2</span>), <span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sequence()</code> 需要使以下成为可能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> asyncTimes4 = <span class="hljs-title function_">sequence</span>(<br>  [<br>    asyncTimes2,<br>    asyncTimes2<br>  ]<br>)<br><br><span class="hljs-title function_">asyncTimes4</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// 4</span><br>&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>当Error发生的时候，需要直接触发最后的callback，未执行的异步函数需要保持未被调用的状态。</p><p><strong>再问问</strong></p><p>能否使用Promise完成题目？能否不使用Promise完成该题目？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">type Callback = (error: Error, data: any) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">type AsyncFunc = (</span><br><span class="hljs-comment">   callback: Callback,</span><br><span class="hljs-comment">   data: any</span><br><span class="hljs-comment">) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">AsyncFunc[]</span>&#125; <span class="hljs-variable">funcs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(callback: Callback) =&gt; void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sequence</span>(<span class="hljs-params">funcs</span>)&#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sequenced</span>(<span class="hljs-params">callback, num</span>) &#123;<br>    <span class="hljs-keyword">if</span>(funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, num);<br>    <span class="hljs-keyword">const</span> [first, ...rest] = funcs;<br>    <span class="hljs-title function_">first</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> error ? <span class="hljs-title function_">callback</span>(error) : <span class="hljs-title function_">sequence</span>(rest)(callback, data), num)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="30-实现async-helper-parallel"><a href="#30-实现async-helper-parallel" class="headerlink" title="30. 实现async helper - parallel()"></a>30. 实现async helper - parallel()</h1><p>本题目是 <a href="https://bigfrontend.dev/zh/problem/implement-async-helper-sequence">29. 实现async helper - <code>sequence()</code></a>的延续。</p><p>请实现async helper - <code>parallel()</code>！ <code>parallel()</code> 有点类似<code>Promise.all()</code>。和29题中的 <code>sequence()</code>不同，异步函数的执行没有先后顺序，在<code>parrallel()</code>中是同时触发。</p><p>本题目中的所有异步函数是如下interface。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AsyncFunc</span> = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">   callback: Callback,</span></span><br><span class="hljs-params"><span class="hljs-function">   data: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>你的<code>parallel()</code> 需要能 <strong>接受 AsyncFunc 数组</strong>，并且返回一个function，这个function将会在所有的异步函数完成或者error发生的时候被触发。</p><p>假设我们有如下3个异步函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">async1</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async2</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async3</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>parallel()</code>需要使得以下成为可能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> all = <span class="hljs-title function_">parallel</span>(<br>  [<br>    async1,<br>    async2,<br>    async3<br>  ]<br>)<br><br><span class="hljs-title function_">all</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// [1, 2, 3]</span><br>&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>当Error发生的时候，只有第一个error需要被传递到最后，剩下的error和data都被忽略。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">type Callback = (error: Error, data: any) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">type AsyncFunc = (</span><br><span class="hljs-comment">   callback: Callback,</span><br><span class="hljs-comment">   data: any</span><br><span class="hljs-comment">) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promisify</span> = fn =&gt; <span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fn</span>(<span class="hljs-function">(<span class="hljs-params">error, output</span>) =&gt;</span> error ? <span class="hljs-title function_">rej</span>(error) : <span class="hljs-title function_">res</span>(output), input);<br>&#125;);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">AsyncFunc[]</span>&#125; <span class="hljs-variable">funcs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(callback: Callback) =&gt; void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parallel</span>(<span class="hljs-params">funcs</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">cb, input</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">Promise</span><br>    .<span class="hljs-title function_">all</span>(funcs.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">promisify</span>(fn)(input)))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">output</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">undefined</span>, output))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">cb</span>(error, <span class="hljs-literal">undefined</span>))<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// Promise 对象是由关键字 new 及其构造函数来创建的。</span><br><span class="hljs-comment">// 该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。</span><br><span class="hljs-comment">// 这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；</span><br><span class="hljs-comment">// 而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。</span><br><br><br><span class="hljs-comment">// 有不明白的地方，在fn 利用input 执行完异步操作后，output 和error 是如何传到外面的？</span><br></code></pre></td></tr></table></figure><hr><h1 id="31-实现async-helper-race"><a href="#31-实现async-helper-race" class="headerlink" title="31. 实现async helper - race()"></a>31. 实现async helper - race()</h1><p>这个题目是<a href="https://bigfrontend.dev/zh/problem/implement-async-helper-parallel">30. 实现async helper - <code>parallel()</code></a>的后续。</p><p>请实现一个async function helper - <code>race()</code> 。 <code>race()</code>有点类似<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race()</a>。 <code>parallel()</code>会等待所有的function执行结束，<code>race()</code>会在任何一个function结束或者产生error的时候调用最终的callback。</p><p>本题目中的所有异步函数是如下interface。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Callback</span> = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AsyncFunc</span> = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">   callback: Callback,</span></span><br><span class="hljs-params"><span class="hljs-function">   data: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>你的<code>race()</code> 需要 <strong>接受 AsyncFunc 数组</strong>，并且返回一个新的函数。这个函数会在任何一个function调用结束或者发生error的时候被调用。</p><p>假设我们有如下3个async function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">async1</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>), <span class="hljs-number">300</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async2</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>), <span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">async3</span> = (<span class="hljs-params">callback</span>) =&gt; &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>), <span class="hljs-number">200</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>你的<code>race()</code> 需要使得如下逻辑成立。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> first = <span class="hljs-title function_">race</span>(<br>  [<br>    async1,<br>    async2,<br>    async3<br>  ]<br>)<br><br><span class="hljs-title function_">first</span>(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <br>   <span class="hljs-comment">// 2, 因为2是第一个成功执行的结果</span><br>&#125;, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">type Callback = (error: Error, data: any) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">type AsyncFunc = (</span><br><span class="hljs-comment">   callback: Callback,</span><br><span class="hljs-comment">   data: any</span><br><span class="hljs-comment">) =&gt; void</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">AsyncFunc[]</span>&#125; <span class="hljs-variable">funcs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(callback: Callback) =&gt; void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">funcs</span>)&#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">cb, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">cbWrapper</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-title function_">cb</span>(...args);<br>      flag = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    funcs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">func</span> =&gt;</span> <span class="hljs-title function_">func</span>(cbWrapper, data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="32-实现Promise-all"><a href="#32-实现Promise-all" class="headerlink" title="32. 实现Promise.all()"></a>32. 实现Promise.all()</h1><blockquote><p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p></blockquote><p>source - <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">MDN</a></p><p>你能否实现自己的 <code>Promise.all()</code> ?</p><p><em>注意</em></p><p><strong>请不要直接使用Promise.all()</strong> ，这并不能帮助你提升。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;any&gt;</span>&#125; <span class="hljs-variable">promises</span> - notice input might have non-Promises</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise&lt;any[]&gt;</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises) &#123;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> promise);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 可以看出，用async 和await 更符合直觉</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> result = [];<br><br>    <span class="hljs-keyword">if</span>(promises.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">res</span>(result);<br><br>    <span class="hljs-keyword">let</span> countPending = promises.<span class="hljs-property">length</span>;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        result[index] = value;<br>        countPending--;<br>        <span class="hljs-keyword">if</span>(countPending === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-title function_">res</span>(result);<br>        &#125;<br>      &#125;, rej)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="33-实现Promise-allSettled"><a href="#33-实现Promise-allSettled" class="headerlink" title="33. 实现Promise.allSettled()"></a>33. 实现Promise.allSettled()</h1><blockquote><p>Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p></blockquote><ul><li>from <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled">MDN</a></li></ul><p>和<code>Promise.all()</code>不同，<code>Promise.allSettled()</code> 会等待所有的promise直到fulfill或者reject。</p><p>你能实现自己的<code>Promise.allSettled()</code> 吗?</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;any&gt;</span>&#125; <span class="hljs-variable">promises</span> - notice that input might contains non-promises</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise&lt;Array&lt;&#123;status: &#x27;fulfilled&#x27;, value: any</span>&#125; | &#123;status: &#x27;rejected&#x27;, reason: any&#125;&gt;&gt;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">allSettled</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> <br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;fulfilled&quot;</span>,<br>      value<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;rejected&quot;</span>,<br>      reason<br>    &#125;<br>  &#125;)<br>  ))<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="34-实现Promise-any"><a href="#34-实现Promise-any" class="headerlink" title="34. 实现Promise.any()"></a>34. 实现Promise.any()</h1><blockquote><p>Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和AggregateError类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和Promise.all()是相反的。</p></blockquote><ul><li>from <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any">MDN</a></li></ul><p>你能实现自己的<code>Promise.any()</code>吗?</p><p><em>注意</em></p><p><code>AggregateError</code> 暂时还没有被Chrome支持。但是你仍然可以使用它因为我们在judge你的code时候添加了AggregateError。</p><p>你可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<br>  <span class="hljs-string">&#x27;No Promise in Promise.any was resolved&#x27;</span>, <br>  errors<br>)<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;Promise&gt;</span>&#125; <span class="hljs-variable">promises</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">any</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> isFullfilled = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> errors = [];<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(!isFullfilled) &#123;<br>          <span class="hljs-title function_">res</span>(data);<br>          isFullfilled = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        errors[index] = error;<br>        <span class="hljs-keyword">if</span>(errors.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-title function_">rej</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<span class="hljs-string">&#x27;none resolved&#x27;</span>, errors));<br>        &#125;<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h1 id="35-实现Promise-race"><a href="#35-实现Promise-race" class="headerlink" title="35. 实现Promise.race()"></a>35. 实现Promise.race()</h1><p>该问题有些类似 <a href="https://bigfrontend.dev/zh/problem/implement-async-helper-race">31. 实现async helper - <code>race()</code></a>，只不过处理的是Promise。</p><blockquote><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。source: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">MDN</a></p></blockquote><p>你能实现自己的<code>Promise.race()</code>吗？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;Promise&gt;</span>&#125; <span class="hljs-variable">promises</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Promise</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> !promises.<span class="hljs-property">length</span> ? <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(res, rej);<br>      <span class="hljs-comment">// promise.then(res, rej);</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="36-实现一个-fake-timer-setTimeout"><a href="#36-实现一个-fake-timer-setTimeout" class="headerlink" title="36. 实现一个 fake timer(setTimeout)"></a>36. 实现一个 fake timer(setTimeout)</h1><p><code>setTimeout</code> 可以设定未来的任务，但是其执行时间并不精确。(<a href="https://javascript.info/event-loop">Event Loop</a>)。</p><p>大多数时候这都不是问题，但是在test的时候却有些头疼。</p><p>比如，<a href="https://bigfrontend.dev/zh/problem/implement-throttle-with-leading-and-trailing-option">5. 手写throttle()并支持leading 和 trailing</a> 中我们就需要比较精确的测试。</p><p>你能否实现一个静态化的<code>setTimeout()</code>和<code>clearTimeout()</code>，而不再有Event Loop的问题。这也正是<a href="https://github.com/sinonjs/fake-timers">FakeTimes</a> 的用途。</p><p>“精确”的意思是，“假设所有的函数的执行耗时为0，同时时间戳从0开始，那么<code>setTimeout(func1, 100)</code>将会精确的在时间戳:100进行执行func1”。</p><p>你需要同时修改<code>Date.now()</code>来提供新的时间戳。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FakeTimer</span> &#123;<br>  <span class="hljs-title function_">install</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// setTimeout(), clearTimeout(), and Date.now() </span><br>    <span class="hljs-comment">// are replaced</span><br>  &#125;<br><br>  <span class="hljs-title function_">uninstall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// restore the original APIs</span><br>    <span class="hljs-comment">// setTimeout(), clearTimeout() and Date.now()</span><br>  &#125;<br><br>  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-comment">// run all the schedule functions in order</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入的代码将会大概像这样进行测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fakeTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FakeTimer</span>()<br>fakeTimer.<span class="hljs-title function_">install</span>()<br><br><span class="hljs-keyword">const</span> logs = []<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">log</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>   logs.<span class="hljs-title function_">push</span>([<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), arg])<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>), <span class="hljs-number">100</span>)<br><span class="hljs-comment">// log &#x27;A&#x27; at 100</span><br><br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>), <span class="hljs-number">110</span>)<br><span class="hljs-built_in">clearTimeout</span>(b)<br><span class="hljs-comment">// b is set but cleared</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>), <span class="hljs-number">200</span>)<br><br><span class="hljs-title function_">expect</span>(logs).<span class="hljs-title function_">toEqual</span>([[<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;A&#x27;</span>], [<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;C&#x27;</span>]])<br><br>fakeTimer.<span class="hljs-title function_">uninstall</span>()<br></code></pre></td></tr></table></figure><p><em>注意</em></p><p>测试的时候只会用到<code>Date.now()</code>，其他的时间相关的函数可以忽略。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FakeTimer</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span> = &#123;<br>    <span class="hljs-attr">setTimeout</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">setTimeout</span>,<br>    <span class="hljs-attr">clearTimeout</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">clearTimeout</span>,<br>    <span class="hljs-attr">dateNow</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span><br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = [];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-number">1</span>;<br>&#125;<br><br>  <span class="hljs-title function_">install</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// replace window.setTimeout, window.clearTimeout, Date.now</span><br>    <span class="hljs-comment">// with your implementation</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">setTimeout</span> = <span class="hljs-function">(<span class="hljs-params">cb, time, ...args</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> id = <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span>++;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(&#123;<br>        cb,<br>        <span class="hljs-attr">time</span>: time+<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span>,<br>        id,<br>        args<br>      &#125;)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a.<span class="hljs-property">time</span> - b.<span class="hljs-property">time</span>);<br>    <span class="hljs-keyword">return</span> id;      <br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">clearTimeout</span> = <span class="hljs-function"><span class="hljs-params">toRemoveId</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj.<span class="hljs-property">id</span> !== toRemoveId);<br>    &#125;<br>    <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-title function_">uninstall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// restore the original implementation of</span><br>    <span class="hljs-comment">// window.setTimeout, window.clearTimeout, Date.now</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">setTimeout</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span>.<span class="hljs-property">setTimeout</span>;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">clearTimeout</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span>.<span class="hljs-property">clearTimeout</span>;<br>    <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">original</span>.<span class="hljs-property">dateNow</span>;<br>  &#125;<br>  <br>  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// run the scheduled functions without waiting</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">let</span> &#123; cb, time, args&#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">shift</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span> = time;<br>      <span class="hljs-title function_">cb</span>(...args);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 本质上是构造一个类，去替换掉原生的计时器方法</span><br></code></pre></td></tr></table></figure><hr><h1 id="37-手写Binary-Search-unique"><a href="#37-手写Binary-Search-unique" class="headerlink" title="37. 手写Binary Search (unique)"></a>37. 手写Binary Search (unique)</h1><p>即使是前端的面试，基本的算法比如<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a>被问到的可能性还是有的。</p><p><strong>请实现一个二分查找，对象是不重复，升序整数数组</strong>。</p><p>请不要直接使用<code>Array.prototype.indexOf()</code>，这不是本题的目的。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span> - ascending unique array</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>)&#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>, end = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(start &lt;= end) &#123;<br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">parseInt</span>((start+end) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(target === arr[mid]) &#123;<br>      <span class="hljs-keyword">return</span> mid;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; arr[mid]) &#123;<br>      end = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      start = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="38-实现jest-spyOn"><a href="#38-实现jest-spyOn" class="headerlink" title="38. 实现jest.spyOn()"></a>38. 实现jest.spyOn()</h1><p>如果你写过单元测试的话，一定很熟悉<code>Spy</code>的用法。</p><p><strong>请自己实现一个spyOn(object, methodName)</strong> ，类似于 <a href="https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname">jest.spyOn()</a>。</p><p>以下是<code>spyOn</code>需要完成的内容。</p><ol><li>spy被调用的时候，原来的method也需要被调用。</li><li>spy需要又一个<code>calls</code>数组，数组中含有所有调用的参数</li></ol><p>以下代码说明了一切。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>   <span class="hljs-attr">data</span>: <span class="hljs-number">1</span>, <br>   <span class="hljs-title function_">increment</span>(<span class="hljs-params">num</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> += num<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> spy = <span class="hljs-title function_">spyOn</span>(obj, <span class="hljs-string">&#x27;increment&#x27;</span>)<br><br>obj.<span class="hljs-title function_">increment</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">data</span>) <span class="hljs-comment">// 2</span><br><br>obj.<span class="hljs-title function_">increment</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">data</span>) <span class="hljs-comment">// 4</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spy.<span class="hljs-property">calls</span>)<br><span class="hljs-comment">// [ [1], [2] ]</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object</span>&#125; <span class="hljs-variable">obj</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">methodName</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">spyOn</span>(<span class="hljs-params">obj, methodName</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> method = obj[methodName];<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> method !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;methodName&#125;</span> is not a function`</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> calls = [];<br>  obj[methodName] = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    calls.<span class="hljs-title function_">push</span>(args);<br>    method.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123; calls &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="39-手写range"><a href="#39-手写range" class="headerlink" title="39. 手写range()"></a>39. 手写range()</h1><p>请实现一个<code>range(from, to)</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)  <br>&#125;<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>这个题目非常简单，注意你不一定必须要返回一个数组，你能想到除了for循环之外更多更炫酷的解法吗？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer</span>&#125; <span class="hljs-variable">from</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">integer</span>&#125; <span class="hljs-variable">to</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">range</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">while</span>(<span class="hljs-keyword">from</span> &lt;= to) &#123;<br>    result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">from</span>++);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 2. implement iterable/iterator protocol</span><br><span class="hljs-comment">// for ... of uses interable protocol</span><br><span class="hljs-comment">// [Symbol.iterator]: () =&gt;  Iterator</span><br><span class="hljs-comment">// next: () =&gt; &#123;done: bolean, value?: any&#125; </span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">range</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// iterable protocol</span><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>      <span class="hljs-comment">// iterator protocol</span><br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">done</span>: <span class="hljs-keyword">from</span> &gt; to,<br>            <span class="hljs-attr">value</span>: <span class="hljs-keyword">from</span>++<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="40-实现Bubble-Sort"><a href="#40-实现Bubble-Sort" class="headerlink" title="40. 实现Bubble Sort"></a>40. 实现Bubble Sort</h1><p>即使是前端开发，也需要掌握基本的排序算法。</p><p>请手写<a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a>。</p><p>请直接修改传入的数组，不要返回新数组。</p><p><em>追问</em></p><p>时间空间复杂度是多少？是否是稳定的排序？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 要遍历的次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i; j++) &#123; <span class="hljs-comment">// 具体遍历的索引</span><br>      <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>        [arr[j] ,arr[j+<span class="hljs-number">1</span>]] = [arr[j+<span class="hljs-number">1</span>], arr[j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 维基百科的示例代码</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bubble_sort</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> i, j, temp;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++)<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i; j++)<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>[j] &gt; <span class="hljs-variable language_">this</span>[j + <span class="hljs-number">1</span>]) &#123;<br>temp = <span class="hljs-variable language_">this</span>[j];<br><span class="hljs-variable language_">this</span>[j] = <span class="hljs-variable language_">this</span>[j + <span class="hljs-number">1</span>];<br><span class="hljs-variable language_">this</span>[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br><span class="hljs-keyword">var</span> num = [<span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">82</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>, <span class="hljs-number">50</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">70</span>];<br>num.<span class="hljs-title function_">bubble_sort</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-property">length</span>; i++)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> += num[i] + <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><hr><h1 id="41-手写Merge-Sort"><a href="#41-手写Merge-Sort" class="headerlink" title="41. 手写Merge Sort"></a>41. 手写Merge Sort</h1><p>即使是前端开发，也需要掌握基本的排序算法。</p><p>请手写<a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a>。</p><p>请直接修改传入的数组，不要返回新数组。</p><p><em>追问</em></p><p>时间空间复杂度是多少？是否是稳定的排序？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 维基百科版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>)&#123;<br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; right.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt; right[<span class="hljs-number">0</span>])&#123;<br>      result.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      result.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(left, right);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>)&#123;<br>  <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span> &lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>  <span class="hljs-keyword">var</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">var</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle);<br>  <span class="hljs-keyword">var</span> right = arr.<span class="hljs-title function_">slice</span>(middle);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">let</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, mid)<br>  <span class="hljs-keyword">let</span> right = arr.<span class="hljs-title function_">slice</span>(mid)<br>  <br>  <span class="hljs-title function_">mergeSort</span>(left)<br>  <span class="hljs-title function_">mergeSort</span>(right)<br>  <br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> (l &lt; left.<span class="hljs-property">length</span> || r &lt; right.<span class="hljs-property">length</span>)<br>    arr[l+r] = (r === right.<span class="hljs-property">length</span> || left[l] &lt;= right[r]) ? left[l++] : right[r++] <span class="hljs-comment">// ⭐⭐</span><br>&#125;<br><span class="hljs-comment">// 很巧妙啊，双指针的写法</span><br><span class="hljs-comment">// r===right.length 是为了让右数组用完后,可以继续进行左数组的赋值.</span><br><span class="hljs-comment">// 如果是左数组用完,判断式子自然为false, 执行右数组的赋值</span><br></code></pre></td></tr></table></figure><hr><h1 id="42-手写-Insertion-Sort"><a href="#42-手写-Insertion-Sort" class="headerlink" title="42. 手写 Insertion Sort"></a>42. 手写 Insertion Sort</h1><p>即使是前端开发，也需要掌握基本的排序算法。</p><p>请手写<a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a>。</p><p>请直接修改传入的数组，不要返回新数组。</p><p><em>追问</em></p><p>时间空间复杂度是多少？是否是稳定的排序？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> key = arr[i];<br>    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>      arr[j+<span class="hljs-number">1</span>] = arr[j];<br>      j--;<br>    &#125;<br>    arr[j+<span class="hljs-number">1</span>] = key;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 插入排序的核心在于, 一个一个比较,腾笼换鸟</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(四)</title>
    <link href="/blog/2021/10/21/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E5%9B%9B/"/>
    <url>/blog/2021/10/21/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="16-实现一个Event-Emitter"><a href="#16-实现一个Event-Emitter" class="headerlink" title="16. 实现一个Event Emitter"></a>16. 实现一个Event Emitter</h1><p>Node.js中有<a href="https://nodejs.org/api/events.html#events_class_eventemitter">Event Emitter</a>，Facebook 也曾经有<a href="https://github.com/facebookarchive/emitter">自己的实现</a> 不过已经archive了。</p><p>请实现你自己的 Event Emitter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emitter</span>()<br></code></pre></td></tr></table></figure><p>它需要支持事件订阅</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sub1  = emitter.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;event1&#x27;</span>, callback1)<br><span class="hljs-keyword">const</span> sub2 = emitter.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;event2&#x27;</span>, callback2)<br><br><span class="hljs-comment">// 同一个callback可以重复订阅同一个事件</span><br><span class="hljs-keyword">const</span> sub3 = emitter.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;event1&#x27;</span>, callback1)<br></code></pre></td></tr></table></figure><p><code>emit(eventName, ...args)</code> 可以用来触发callback</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// callback1 会被调用两次</span><br></code></pre></td></tr></table></figure><p><code>subscribe()</code>返回一个含有<code>release()</code>的对象，可以用来取消订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">sub1.<span class="hljs-title function_">release</span>()<br>sub3.<span class="hljs-title function_">release</span>()<br><span class="hljs-comment">// 现在即使&#x27;event1&#x27;被触发, </span><br><span class="hljs-comment">// callback1 也不会被调用</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// please complete the implementation</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  eventCache = &#123;&#125;; cbId = <span class="hljs-number">0</span>;<br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">eventName, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> eventKey = eventName, funcId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cbId</span>++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey] || &#123;&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey][funcId] = callback;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">release</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventKey][funcId];<br>      &#125;<br>    &#125;<br><br>  &#125;<br>  <br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">eventName, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventName] &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">eventCache</span>[eventName]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args))<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Emitter 实际上就是一个存储回调的特殊对象</span><br></code></pre></td></tr></table></figure><hr><h1 id="17-实现一个DOM-element-store"><a href="#17-实现一个DOM-element-store" class="headerlink" title="17. 实现一个DOM element store"></a>17. 实现一个DOM element store</h1><p>JavaScript中有<code>Map</code>，我们可以用任何data做key，即便是DOM元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(domNode, somedata)<br></code></pre></td></tr></table></figure><p>如果运行的JavaScript不支持Map，我们如何能让上述代码能够工作？</p><p>请在不利用Map的条件下实现一个Node Store，支持DOM element作为key。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeStore</span> &#123;<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">node, value</span>) &#123;<br><br>  &#125;<br>  <br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">node</span>) &#123;<br><br>  &#125;<br>  <br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">node</span>) &#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以实现一个通用的Map polyfill。或者利用以下DOM元素的特性来做文章？</p><p>请注意时间空间复杂度。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeStore</span> &#123;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span> = &#123;&#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span> = <span class="hljs-title class_">Symbol</span>();<br>  &#125;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">node</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">value</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">node, value</span>) &#123;<br>    node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>] = <span class="hljs-title class_">Symbol</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>]] = value;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">node</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">any</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">node</span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>]];<br>  &#125;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">node</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Boolean</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">node</span>) &#123;<br>    <span class="hljs-keyword">return</span> !!<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>[node[<span class="hljs-variable language_">this</span>.<span class="hljs-property">nodeKey</span>]];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 基本思路就是给node 加一个属性，设置一个独一无二的值Symbol()，然后存起来</span><br></code></pre></td></tr></table></figure><hr><h1 id="18-优化一个function"><a href="#18-优化一个function" class="headerlink" title="18. 优化一个function"></a>18. 优化一个function</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// items是一个array</span><br><span class="hljs-comment">// 包含的元素有 &gt;=3 个属性</span><br><br><span class="hljs-keyword">let</span> items = [<br>  &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;tv&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;, <br>  &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;silver&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;phone&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;,<br>  &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;book&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">17</span>&#125;<br>] <br><br><span class="hljs-comment">// 一个由key和value组成的array</span><br><span class="hljs-keyword">const</span> excludes = [ <br>  &#123;<span class="hljs-attr">k</span>: <span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-attr">v</span>: <span class="hljs-string">&#x27;silver&#x27;</span>&#125;, <br>  &#123;<span class="hljs-attr">k</span>: <span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-attr">v</span>: <span class="hljs-string">&#x27;tv&#x27;</span>&#125;, <br>  ...<br>] <br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">excludeItems</span>(<span class="hljs-params">items, excludes</span>) &#123; <br>  excludes.<span class="hljs-title function_">forEach</span>( <span class="hljs-function"><span class="hljs-params">pair</span> =&gt;</span> &#123; <br>    items = items.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[pair.<span class="hljs-property">k</span>] === item[pair.<span class="hljs-property">v</span>])<br>  &#125;)<br> <br>  <span class="hljs-keyword">return</span> items<br>&#125; <br></code></pre></td></tr></table></figure><ol><li>上述<code>excludeItems</code>方法是什么用途?</li><li>上述方法是否和设想的一样在运作?</li><li>上述方法的时间复杂度是?</li><li>你能否优化以下?</li></ol><p><em>注意</em></p><p>BFE.dev仅仅根据结果进行judge，不会考虑时间成本。请提交你觉得最好的解答。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object[]</span>&#125; <span class="hljs-variable">items</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@excludes</span> &#123;<span class="hljs-type"> Array&lt; &#123;k: string, v: any</span>&#125; &gt;&#125; excludes</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">object[]</span>&#125; <span class="hljs-variable">items</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array&lt; &#123;k: string, v: any</span>&#125; &gt;&#125; excludes</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">excludeItems</span>(<span class="hljs-params">items, excludes</span>) &#123;<br>  items = items.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> excludes) &#123;<br>      <span class="hljs-keyword">if</span>(item[pair.<span class="hljs-property">k</span>] === pair.<span class="hljs-property">v</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> items;<br>&#125;<br><br><span class="hljs-comment">// 不难，搞清楚filter 返回的数组以及对象的属性取值即可</span><br></code></pre></td></tr></table></figure><hr><h1 id="19-相同结构的DOM-tree上面寻找对应的节点"><a href="#19-相同结构的DOM-tree上面寻找对应的节点" class="headerlink" title="19. 相同结构的DOM tree上面寻找对应的节点"></a>19. 相同结构的DOM tree上面寻找对应的节点</h1><p>给定两个完全一样的DOM Tree <strong>A</strong>和<strong>B</strong>，以及<strong>A</strong>中的元素<strong>a</strong>，请找到<strong>B</strong>中对应的元素<strong>b</strong>。</p><p><strong>补充说明</strong></p><p>这个问题可以出在一般的树结构上，DOM Tree只是一个特例。</p><p>你能否既通过递归也能通过迭代来解决该问题。</p><p>既然是DOM Tree，能否提供一个利用到DOM tree特性的解法？</p><p>你的解法的时空复杂度是多少？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootA</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootB</span> - rootA and rootB are clone of each other</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">nodeA</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">findCorrespondingNode</span> = (<span class="hljs-params">rootA, rootB, target</span>) =&gt; &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span>(rootA === target) &#123;<br>    <span class="hljs-keyword">return</span> rootB;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rootA.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> found = <span class="hljs-title function_">findCorrespondingNode</span>(rootA.<span class="hljs-property">children</span>[i], rootB.<span class="hljs-property">children</span>[i], target);<br>    <span class="hljs-keyword">if</span>(found) <span class="hljs-keyword">return</span> found;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// BFS Solution</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootA</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootB</span> - rootA and rootB are clone of each other</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">nodeA</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">findCorrespondingNode</span> = (<span class="hljs-params">rootA, rootB, target</span>) =&gt; &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span> (rootA === target) &#123;<br>    <span class="hljs-keyword">return</span> rootB;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> queueA = [rootA];<br>  <span class="hljs-keyword">const</span> queueB = [rootB];<br><br>  <span class="hljs-keyword">while</span>(queueA.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> currentElementA = queueA.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-keyword">const</span> currentElementB = queueB.<span class="hljs-title function_">shift</span>();<br><br>    <span class="hljs-keyword">if</span> (currentElementA === target) &#123;<br>      <span class="hljs-keyword">return</span> currentElementB;<br>    &#125;<br><br>    queueA.<span class="hljs-title function_">push</span>(...currentElementA.<span class="hljs-property">children</span>);<br>    queueB.<span class="hljs-title function_">push</span>(...currentElementB.<span class="hljs-property">children</span>);    <br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><br><span class="hljs-comment">// Iterative DFS</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootA</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">rootB</span> - rootA and rootB are clone of each other</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">nodeA</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">findCorrespondingNode</span> = (<span class="hljs-params">rootA, rootB, target</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> stack = [[rootA, rootB]];<br>  <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> [leftNode, rightNode] = stack.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">if</span> (leftNode === target) <span class="hljs-keyword">return</span> rightNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; leftNode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      stack.<span class="hljs-title function_">push</span>([leftNode.<span class="hljs-property">children</span>[i], rightNode.<span class="hljs-property">children</span>[i]]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="20-检测-data-type"><a href="#20-检测-data-type" class="headerlink" title="20. 检测 data type"></a>20. 检测 data type</h1><p>这是个简单的问题。</p><p>对于JavaScript中的所有<a href="https://javascript.info/types">基础数据类型</a>，请实现一个方法进行检测。</p><p>除了基础数据类型之外，你的方法需要额外支持常见的类型包括<code>Array</code>、<code>ArrayBuffer</code>、<code>Map</code>、 <code>Set</code>、<code>Date</code> 和 <code>Function</code>。</p><p>该题目的目标并不是想要你列举出所有数据类型，而是想要你证明你能解决该类型的问题。</p><p>类型名请返回小写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">detectType</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// &#x27;number&#x27;</span><br><span class="hljs-title function_">detectType</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()) <span class="hljs-comment">// &#x27;map&#x27;</span><br><span class="hljs-title function_">detectType</span>([]) <span class="hljs-comment">// &#x27;array&#x27;</span><br><span class="hljs-title function_">detectType</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &#x27;null&#x27;</span><br><br><span class="hljs-comment">// judge的时候会有更多</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">data</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectType</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">FileReader</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;object&#x27;</span>; <span class="hljs-comment">// 面向测试编程</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">toLowerCase</span>();<br>&#125;<br><br><span class="hljs-comment">// 用Object.prototype 是因为方法就定义在原型上, 控制台输出 Object 的内容可以查看相关方法</span><br><span class="hljs-comment">// 实例对象中找不到方法，才回去原型上去找，而不是对象的原型属性</span><br></code></pre></td></tr></table></figure><hr><h1 id="21-手写JSON-stringify"><a href="#21-手写JSON-stringify" class="headerlink" title="21. 手写JSON.stringify()"></a>21. 手写JSON.stringify()</h1><p>相信你必定用过<code>JSON.stringify()</code>，你知道它是如何工作的吗？</p><p>请脑补以下其内部逻辑，然后参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">MDN的说明</a>，其实并不简单。</p><p>回到本题目，请实现你自己的<code>JSON.stringify()</code>。</p><p>在真正面试的时候，面试官并不期待你能完全按照spec来实现，请预先和面试官决定需要支持的范围。为了达到练习的目的，该题目将会测试多种数据类型，请尽量考虑周全。</p><p>并请注意循环引用。</p><p><em>注意</em></p><p><code>JSON.stringify()</code> 有额外两个参数，这里并不需要支持。</p><p>不要直接用<code>JSON.stringify()</code>糊弄BFE.dev，这样做并不能帮助你的面试。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">data</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">stringify</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> type = <span class="hljs-title function_">getType</span>(data);<br>  <span class="hljs-keyword">switch</span>(type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;data&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;boolean&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;data&#125;</span>`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;null&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;undefined&#x27;</span>:    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;symbol&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;null&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;function&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;date&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;data.toISOString()&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;bigint&#x27;</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;can not stringify &#x27;bigint&#x27; type&quot;</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;array&#x27;</span>:<br>      <span class="hljs-keyword">const</span> arr = data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-title function_">stringify</span>(v));<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;arr.join(<span class="hljs-string">&#x27;,&#x27;</span>)&#125;</span>]`</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;object&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;map&#x27;</span>:<br>      <span class="hljs-keyword">const</span> items = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(data).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> [key, value] = cur;<br>        <span class="hljs-keyword">if</span>(value === <span class="hljs-literal">undefined</span>) &#123;<br>          <span class="hljs-keyword">return</span> acc;<br>        &#125;<br>        acc.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;stringify(key)&#125;</span>:<span class="hljs-subst">$&#123;stringify(value)&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span> acc;<br>      &#125;, [])<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;<span class="hljs-subst">$&#123;items.join(<span class="hljs-string">&#x27;,&#x27;</span>)&#125;</span>&#125;`</span><br><span class="hljs-comment">// 边界符号&#x27; &quot; [ &#123;符号只是给编译器用来识别数据类型用的, 数据才是我们关注的</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(data)) &#123; <span class="hljs-comment">// isNaN 针对 NaN 和非数返回true; 而Number.isNaN 针对 NaN 返回true;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;null&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data === <span class="hljs-title class_">Infinity</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;null&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">toLowerCase</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 面向测试编程的伟大实践</span><br></code></pre></td></tr></table></figure><hr><h1 id="22-手写JSON-parse"><a href="#22-手写JSON-parse" class="headerlink" title="22. 手写JSON.parse()"></a>22. 手写JSON.parse()</h1><p>该问题是 <a href="https://bigfrontend.dev/zh/problem/implement-JSON-stringify">21. 手写JSON.stringify()</a>的后续。</p><p>相信你已经很熟悉<code>JSON.parse()</code>了，你能自己实现一个吗？</p><p>假若你还不熟悉spec的话，可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">MDN 的说明</a>，也许会有帮助。</p><p><code>JSON.parse()</code> 支持第二个参数<code>reviver</code>，你可以在本题目中忽略。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">str</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object | Array | string | number | boolean | null</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">`return <span class="hljs-subst">$&#123;str.replace(/\<span class="hljs-string">&quot;/g, &quot;</span><span class="hljs-string">&#x27;&quot;)&#125;`))();</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">  if(str !== JSON.stringify(result)) &#123;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">    throw new Error(&#x27;</span>Has A <span class="hljs-built_in">Error</span><span class="hljs-string">&#x27;);</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">  &#125;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">  return result;</span></span></span><br><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">&#125;</span></span></span><br></code></pre></td></tr></table></figure><hr><h1 id="23-实现一个sum-方法"><a href="#23-实现一个sum-方法" class="headerlink" title="23. 实现一个sum()方法"></a>23. 实现一个sum()方法</h1><p>实现一个 <code>sum()</code>，使得如下判断成立。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sum1 = <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)<br><span class="hljs-title function_">sum1</span>(<span class="hljs-number">2</span>) == <span class="hljs-number">3</span> <span class="hljs-comment">// true</span><br><span class="hljs-title function_">sum1</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">4</span> <span class="hljs-comment">// true</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) == <span class="hljs-number">6</span> <span class="hljs-comment">// true</span><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">5</span>)(-<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) == <span class="hljs-number">6</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">num</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = b =&gt; <span class="hljs-title function_">sum</span>(num + b);<br>  fn[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>] = <span class="hljs-function">() =&gt;</span> num;<br>  <span class="hljs-keyword">return</span> fn;<br>&#125;<br><span class="hljs-comment">// 分析：函数既可以和数值进行比较，又可以进行函数调用，那么肯定是在内部的一些特殊属性上做了手脚</span><br></code></pre></td></tr></table></figure><hr><h1 id="24-用JavaScript手写一个Priority-Queue"><a href="#24-用JavaScript手写一个Priority-Queue" class="headerlink" title="24. 用JavaScript手写一个Priority Queue"></a>24. 用JavaScript手写一个Priority Queue</h1><p><a href="https://storm.cis.fordham.edu/~yli/documents/CISC2200Spring15/Graph.pdf">优先队列(Priority Queue)</a> 是在算法题目中经常用到的数据结构。特别是<strong>Top-k</strong>系列问题非常有效，因为它可以避免整体的排序。</p><p>JavaScript中没有原生的优先队列。在真实的面试中，你可以告诉面试官说“假设我们已经又一个优先队列的实现我可以直接使用”，因为没有时间让我们去手写一个优先队列。</p><p>但是这不妨碍优先队列成为一个很好的联手题目，所以请手写一个优先队列！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span> &#123;<br>  <span class="hljs-comment">// 构造函数接受一个compare函数</span><br>  <span class="hljs-comment">// compare返回的-1, 0, 1决定元素是否优先被去除</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compare</span>) &#123;<br>  <br>  &#125;<br>  <br>  <span class="hljs-comment">// 添加一个元素</span><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">element</span>) &#123;<br><br>  &#125;<br><br>  <span class="hljs-comment">// 去除头元素并返回</span><br>  <span class="hljs-title function_">poll</span>(<span class="hljs-params"></span>) &#123;<br>  <br>  &#125;<br><br>  <span class="hljs-comment">// 取得头元素</span><br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;<br><br>  <span class="hljs-comment">// 取得元素数量</span><br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下的例子可能更好理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br><span class="hljs-comment">// (a, b) =&gt; a - b 意味着更小的元素排序更靠前</span><br><span class="hljs-comment">// 所以最小的元素首先被去除</span><br><br>pq.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>)<br><span class="hljs-comment">// 5是唯一元素</span><br><br>pq.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// 2被添加</span><br><br>pq.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 1被添加</span><br><br>pq.<span class="hljs-title function_">peek</span>()<br><span class="hljs-comment">//  因为小元素靠前，这里返回1</span><br><br>pq.<span class="hljs-title function_">poll</span>()<br><span class="hljs-comment">// 1 </span><br><span class="hljs-comment">// 1 被去除，剩下2和5</span><br><br>pq.<span class="hljs-title function_">peek</span>()<br><span class="hljs-comment">// 2，此时2是最小</span><br><br>pq.<span class="hljs-title function_">poll</span>()<br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 2被去除，剩下了5</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// complete the implementation</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">(a: any, b: any) =&gt; -1 | 0 | 1</span>&#125; <span class="hljs-variable">compare</span> - </span><br><span class="hljs-comment">   * compare function, similar to parameter of Array.prototype.sort</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compare</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compare</span> = compare;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = [];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * return &#123;number&#125; amount of items</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * returns the head element</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">element</span> - new element to add</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">element</span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(element);<br>   <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compare</span>) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compare</span>);<br>   &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * remove the head element</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">any</span>&#125; the head element</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">poll</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">shift</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 很低效的操作</span><br><span class="hljs-comment">// There are many ways to implement a priority queue</span><br><span class="hljs-comment">// – An unsorted List- dequeuing would require searching</span><br><span class="hljs-comment">// through the entire list – An Array-Based Sorted List- Enqueuing is expensive</span><br><span class="hljs-comment">// – A Linked Sorted List- Enqueuing again is 0(N) – A Binary Search Tree- On average, 0(log2N) steps for</span><br><span class="hljs-comment">//  both enqueue and dequeue</span><br></code></pre></td></tr></table></figure><hr><h1 id="25-更新数组的顺序"><a href="#25-更新数组的顺序" class="headerlink" title="25. 更新数组的顺序"></a>25. 更新数组的顺序</h1><p>假设我们又一个数组<strong>A</strong>，以及另外一个整数数组 <strong>B</strong>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> A = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>]<br><span class="hljs-keyword">const</span> B = [<span class="hljs-number">1</span>,   <span class="hljs-number">5</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">3</span>,   <span class="hljs-number">2</span>,   <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>你需要对A进行重新排序，A[i]的新位置将在B[i]，也就是说B是A的各个元素的新索引。</p><p>上述例子进行重排过后，应该得到如下结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br></code></pre></td></tr></table></figure><p>传入的数据保证是有效的。</p><p><em>继续问问</em></p><p>使用额外的<code>O(n)</code>空间很简单就能完成该题目，你能不实用额外空间完成该题目吗？</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any[]</span>&#125; <span class="hljs-variable">items</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">newOrder</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sort</span>(<span class="hljs-params">items, newOrder</span>) &#123;<br>  <span class="hljs-comment">// reorder items inline</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key=<span class="hljs-number">0</span>; key&lt;items.<span class="hljs-property">length</span>; key++)&#123;<br>    <span class="hljs-keyword">let</span> value =newOrder[key];<br>    [items[value], items[key]] = [items[key], items[value]];<br>    [newOrder[key], newOrder[value]] = [newOrder[value], newOrder[key]];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用Object.entries() 就无法获取变换位置后的数组值了</span><br></code></pre></td></tr></table></figure><hr><h1 id="26-实现Object-assign"><a href="#26-实现Object-assign" class="headerlink" title="26. 实现Object.assign()"></a>26. 实现Object.assign()</h1><p><em><code>Object.assign() </code>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</em> (source: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN</a>)</p><p>这个方法很常用，实际上<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法</a>的内部逻辑和<code>Object.assign()</code> 是一样的(<a href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md">source</a>)。以下两行代码完全等价。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> aClone = &#123; ...a &#125;;<br><span class="hljs-keyword">let</span> aClone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, a);<br></code></pre></td></tr></table></figure><p>这是个简单的题目，请自行实现<code>Object.assign()</code>。</p><p><em>注意</em></p><p><strong>不要直接使用Object.assign()</strong> 这不会对你的能力提高有帮助。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any[]</span>&#125; <span class="hljs-variable">sources</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">object</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectAssign</span>(<span class="hljs-params">target, ...sources</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">if</span>([<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>].<span class="hljs-title function_">includes</span>(target)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected function to throw an exception.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(target);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> sources) &#123;<br>    <span class="hljs-keyword">if</span>([<span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-string">&#x27;function&#x27;</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-keyword">typeof</span> item) &amp;&amp; item !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(item));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-comment">// 这个题目的知识有点冷门</span><br></code></pre></td></tr></table></figure><hr><h1 id="27-实现completeAssign"><a href="#27-实现completeAssign" class="headerlink" title="27. 实现completeAssign()"></a>27. 实现completeAssign()</h1><p>本题是 <a href="https://bigfrontend.dev/zh/problem/implement-object-assign">26. 实现Object.assign()</a>的延续。</p><p><code>Object.assign()</code> 处理的是可枚举属性，所以getters不会被复制，不可枚举属性被忽略。</p><p>假设我们有如下的object。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> source = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<br>  &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> <span class="hljs-comment">// prototype</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 可枚举 data descriptor</span><br>    &#125;,<br>    <span class="hljs-attr">c</span>: &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 不可枚举data descriptor</span><br>    &#125;,<br>    <span class="hljs-attr">d</span>: &#123; <span class="hljs-comment">// 不可枚举 accessor descriptor </span><br>      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_d</span>;<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_d</span> = value<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">e</span>: &#123; <span class="hljs-comment">// 可枚举 accessor descriptor </span><br>      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_e</span>;<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_e</span> = value<br>      &#125;,<br>      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><p>如果我们调用 <code>Object.assign()</code> 的话，我们得到的是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, source)<br><br><span class="hljs-comment">// &#123;b: 4, e: undefined&#125;</span><br><span class="hljs-comment">// e 是undefined 因为 `this._e` 是undefined</span><br></code></pre></td></tr></table></figure><p>这也许不是我们想要的结果，你能否实现一个<code>completeAssign()</code>，使得data descriptors和 accessor descriptors都能被拷贝？</p><p>如果你还不熟悉descriptors，请参照<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN的说明</a>。</p><p>该问题单纯地想要考考你对descriptors的理解。</p><p>祝你好运！</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeAssign</span>(<span class="hljs-params">target, ...sources</span>) &#123;<br>  <span class="hljs-keyword">if</span>([<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>].<span class="hljs-title function_">includes</span>(target)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected function to throw an exception.&quot;</span>);<br>  &#125;<br>  target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(target);<br>  sources.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>([<span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-string">&#x27;function&#x27;</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-keyword">typeof</span> source) &amp;&amp; source !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(target, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(source));<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="28-实现clearAllTimeout"><a href="#28-实现clearAllTimeout" class="headerlink" title="28. 实现clearAllTimeout()"></a>28. 实现clearAllTimeout()</h1><p><code>window.setTimeout()</code> 可以用来设定未来将要执行的任务。</p><p>你能否实现一个<code>clearAllTimeout()</code> 来取消掉所有未执行的timer？比如当页面跳转的时候我们或许想要清除掉所有的timer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(func1, <span class="hljs-number">10000</span>)<br><span class="hljs-built_in">setTimeout</span>(func2, <span class="hljs-number">10000</span>)<br><span class="hljs-built_in">setTimeout</span>(func3, <span class="hljs-number">10000</span>)<br><br><span class="hljs-comment">// 3个方法都是设定在10秒以后</span><br><span class="hljs-title function_">clearAllTimeout</span>()<br><br><span class="hljs-comment">// 所有方法的timer都被取消掉了</span><br></code></pre></td></tr></table></figure><p><em>注意</em></p><p>你需要保证<code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 还是原来的interface，虽然你可以替换其中的逻辑。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cancel all timer from window.setTimeout</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clearAllTimeout</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  timers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(v));<br>&#125;<br><br><span class="hljs-keyword">let</span> timers = [];<br><span class="hljs-keyword">const</span> originTimer = <span class="hljs-built_in">setTimeout</span>;<br><span class="hljs-built_in">setTimeout</span> = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-title function_">originTimer</span>(...args);<br>  timers.<span class="hljs-title function_">push</span>(timer);<br>  <span class="hljs-keyword">return</span> timer;<br>&#125;<br><br><span class="hljs-comment">// setTimeout、clearTimeout 针对单一事件，要改变它的逻辑，就需要定义一个全局变量保存所有timerId，并且替换原来的setTimeout 的逻辑，</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(三)</title>
    <link href="/blog/2021/10/20/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%B8%89/"/>
    <url>/blog/2021/10/20/bigfrontend-%E4%BB%A3%E7%A0%81%E9%A2%98-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="8-手写shuffle-随机打乱一个数组"><a href="#8-手写shuffle-随机打乱一个数组" class="headerlink" title="8. 手写shuffle()随机打乱一个数组"></a>8. 手写shuffle()随机打乱一个数组</h1><p>能否手写一个shuffle() ?</p><p>当传入一个数组的时候，shuffle()需要更换元素的顺序，每一种最终的数列都需要被相等的概率生成。</p><p>比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>以上的数组共有4! = 24 中不同的排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<br>...<br><br><br></code></pre></td></tr></table></figure><p>你写的 <code>shuffle()</code> 需要按照相同的概率(1/24)来返回上述排列中的一种。</p><p><em>注意</em></p><p>你写的 <code>shuffle()</code>会被调用很多次，计算出每一种出现的概率，然后根据<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE">标准差</a>来判断</p><p>ref: <a href="https://javascript.info/task/shuffle">https://javascript.info/task/shuffle</a></p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any[]</span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-comment">// modify the arr inline to change the order randomly</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">let</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>    [array[i], array[j]] = [array[j], array[i]];<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// function shuffle(array) &#123;</span><br><span class="hljs-comment">//  array.sort(() =&gt; Math.random() - 0.5);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 用这个有问题</span><br><br></code></pre></td></tr></table></figure><hr><h1 id="9-解密消息"><a href="#9-解密消息" class="headerlink" title="9. 解密消息"></a>9. 解密消息</h1><p>在一个字符串的二维数组中，有一个隐藏字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">I B C A L K A<br>D R F C A E A<br>G H O E L A D <br></code></pre></td></tr></table></figure><p>可以按照如下步骤找出隐藏消息</p><ol><li>从左上开始，向右下前进</li><li>无法前进的时候，向右上前进</li><li>无法前进的时候，向右下前进</li><li>2和3的重复</li></ol><p>无法前进的时候，经过的字符就就是隐藏信息</p><p>比如上面的二维数组的话，隐藏消息是<code>IROCLED</code></p><p>注：如果没有的话，返回空字符串</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[][]</span>&#125; <span class="hljs-variable">message</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">decode</span>(<span class="hljs-params">message</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> cols = message[<span class="hljs-number">0</span>]?.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> direction = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(cols &gt; j) &#123;<br>    result += message[i][j];<br>    <span class="hljs-keyword">if</span>(!message[i+direction]) &#123;<br>      direction *= -<span class="hljs-number">1</span>;<br>    &#125;<br>    i += direction;<br>    j++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="10-找出第一个不良版本"><a href="#10-找出第一个不良版本" class="headerlink" title="10. 找出第一个不良版本"></a>10. 找出第一个不良版本</h1><p>一个程序有多个版本，不知道什么时候开始有个bug混在其中。请你找到第一个坏掉的版本。</p><p>特定版本是否有bug，可以用<code>isBad(revision)</code>进行判定。</p><p><em>注意</em></p><ol><li>传入的都是非负整数</li><li>如果没有找到，返回-1</li></ol><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 二分法的妙用</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> type TypIsBad = (version: number) =&gt; boolean</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TypIsBad</span>&#125; isBad </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">isBad</span>) &#123;<br><span class="hljs-comment">// firstBadVersion receive a check function isBad</span><br>  <span class="hljs-comment">// and should return a closure which accepts a version number(integer)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">version</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// write your code to return the first bad version</span><br>    <span class="hljs-comment">// if none found, return -1</span><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> end = version;<br>    <span class="hljs-keyword">while</span>(start &lt;= end) &#123;<br>      <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((start+end)/<span class="hljs-number">2</span>);<br>      <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isBad</span>(mid)) &#123;<br>        end = mid - <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        start = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> start &lt;= version ? start : -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="11-什么是Composition-实现pipe"><a href="#11-什么是Composition-实现pipe" class="headerlink" title="11. 什么是Composition?实现pipe()"></a>11. 什么是Composition?实现pipe()</h1><p>什么是Composition? 其实并不难理解，看看<a href="https://whatthefuck.is/composition">@dan_abramov ‘s 的说明</a>就知道了。</p><p>现在需要你自己写一个<code>pipe()</code> 方法。</p><p>假设有一些简单的四则运算方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">times</span> = (<span class="hljs-params">y</span>) =&gt;  <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * y<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">plus</span> = (<span class="hljs-params">y</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + y<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract</span> = (<span class="hljs-params">y</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x - y<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">divide</span> = (<span class="hljs-params">y</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x / y<br></code></pre></td></tr></table></figure><p><code>pipe()</code> 可以用来生成新的计算方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">pipe</span>([<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">2</span>),<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">3</span>)<br>])  <br><span class="hljs-comment">// x * 2 * 3</span><br><br><span class="hljs-title function_">pipe</span>([<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">2</span>),<br>  <span class="hljs-title function_">plus</span>(<span class="hljs-number">3</span>),<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">4</span>)<br>]) <br><span class="hljs-comment">// (x * 2 + 3) * 4</span><br><br><span class="hljs-title function_">pipe</span>([<br>  <span class="hljs-title function_">times</span>(<span class="hljs-number">2</span>),<br>  <span class="hljs-title function_">subtract</span>(<span class="hljs-number">3</span>),<br>  <span class="hljs-title function_">divide</span>(<span class="hljs-number">4</span>)<br>]) <br><span class="hljs-comment">// (x * 2 - 3) / 4</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>为了简单，可以假设传给<code>pipe()</code>的方法都只有一个参数</li></ol><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array&lt;(arg: any) =&gt; any&gt;</span>&#125; funcs </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">(arg: any) =&gt; any</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pipe</span>(<span class="hljs-params">funcs</span>) &#123;<br><span class="hljs-comment">// your code here</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">result, func</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> func.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, result);<br>&#125;, arg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="12-实现-Immutability-helper"><a href="#12-实现-Immutability-helper" class="headerlink" title="12. 实现 Immutability helper"></a>12. 实现 Immutability helper</h1><p>如果你使用React，你肯定会遇到想要修改state的一部分的情况。</p><p>比如下面的state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想要修改<code>d</code>来生成一个新的state，我们可以用 <a href="https://lodash.com/docs/4.17.15#cloneDeep">_.cloneDeep</a>，但是这样没必要因为<code>state.a</code>并不需要被clone。</p><p>一个更好的办法是如下的浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newState = &#123;<br>  ...state,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是又有了新问题，如果我们同时需要修改<code>c</code>的话，我们需要写很复杂的代码，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newState = &#123;<br>  ...state,<br>  <span class="hljs-attr">a</span>: &#123;<br>    ...state.<span class="hljs-property">a</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>       ...state.<span class="hljs-property">b</span>,<br>       <span class="hljs-attr">c</span>: <span class="hljs-number">2</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这显然还不如cloneDeep。</p><p><a href="https://reactjs.org/docs/update.html">Immutability Helper</a> 可以很好的解决这个问题。</p><p>请实现你自己的Immutability helper <code>update()</code>，需要支持如下调用</p><h3 id="1-push-array-添加元素到数组"><a href="#1-push-array-添加元素到数组" class="headerlink" title="1. {$push: array} 添加元素到数组"></a>1. <code>&#123;$push: array&#125;</code> 添加元素到数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> newArr = <span class="hljs-title function_">update</span>(arr, &#123;<span class="hljs-attr">$push</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]&#125;)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><h3 id="2-set-any-修改目标"><a href="#2-set-any-修改目标" class="headerlink" title="2. {$set: any} 修改目标"></a>2. {$set: any} 修改目标</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">const</span> newState = <span class="hljs-title function_">update</span>(<br>  state, <br>  &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: &#123;<span class="hljs-attr">$set</span>: <span class="hljs-number">3</span>&#125;&#125;&#125;&#125;<br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  a: &#123;</span><br><span class="hljs-comment">    b: &#123;</span><br><span class="hljs-comment">      c: 3</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  d: 2</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>注意我们可以通过<code>$set</code>来修改数组中的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> newArr = <span class="hljs-title function_">update</span>(<br>  arr, <br>  &#123;<span class="hljs-number">0</span>: &#123;<span class="hljs-attr">$set</span>: <span class="hljs-number">0</span>&#125;&#125;<br>)<br><span class="hljs-comment">//  [0, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="3-merge-object-合并到目标object"><a href="#3-merge-object-合并到目标object" class="headerlink" title="3. {$merge: object} 合并到目标object"></a>3. {$merge: object} 合并到目标object</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-keyword">const</span> newState = <span class="hljs-title function_">update</span>(<br>  state, <br>  &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">$merge</span>: &#123;<span class="hljs-attr">e</span>: <span class="hljs-number">5</span>&#125;&#125;&#125;&#125;<br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  a: &#123;</span><br><span class="hljs-comment">    b: &#123;</span><br><span class="hljs-comment">      c: 1,</span><br><span class="hljs-comment">      e: 5</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  d: 2</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="4-apply-function-自定义修改"><a href="#4-apply-function-自定义修改" class="headerlink" title="4. {$apply: function} 自定义修改"></a>4. {$apply: function} 自定义修改</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> newArr = <span class="hljs-title function_">update</span>(arr, &#123;<span class="hljs-number">0</span>: &#123;<span class="hljs-attr">$apply</span>: <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item * <span class="hljs-number">2</span>&#125;&#125;)<br><span class="hljs-comment">// [2, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">any</span>&#125; <span class="hljs-variable">data</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">command</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data, command</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(command)) &#123;<br>    <span class="hljs-keyword">switch</span>(key) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$push&#x27;</span>:<br>        <span class="hljs-keyword">return</span> [...data, ...value];<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$set&#x27;</span>:<br>        <span class="hljs-keyword">return</span> value;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$merge&#x27;</span>:<br>        <span class="hljs-keyword">if</span>(!(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Bad merge&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;...data, ...value&#125;;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$apply&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">value</span>(data);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">if</span>(data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>          <span class="hljs-keyword">const</span> res = [...data]; <span class="hljs-comment">// 做一个拷贝，原数组取值，现数组设置值</span><br>          res[key] = <span class="hljs-title function_">update</span>(data[key], value);<br>          <span class="hljs-keyword">return</span> res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123;<br>            ...data,<br>            [key]: <span class="hljs-title function_">update</span>(data[key], value)<br>          &#125;<br>        &#125;<br>    &#125;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 用到了递归，妙啊</span><br></code></pre></td></tr></table></figure><hr><h1 id="13-利用栈-Stack-创建队列-Queue"><a href="#13-利用栈-Stack-创建队列-Queue" class="headerlink" title="13. 利用栈(Stack)创建队列(Queue)"></a>13. 利用栈(Stack)创建队列(Queue)</h1><p>在JavaScript中，我们可以用Array来充作Stack或者Queue.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// 变为 [1, 2, 3, 4, 5]</span><br>arr.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 5, 数组变为 [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>上述是Stack的用法，以下则是Queue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">//  [1, 2, 3, 4, 5]</span><br>arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">// 1, 现在数组是 [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>假设你有Stack，包含如下的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123; <span class="hljs-comment">/* 添加元素到stack */</span> &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取top 元素 */</span> &#125;<br>  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 弹出top 元素 */</span>&#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取元素数量 */</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你能否通过只使用Stack实现一个包含如下方法的Queue？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br>  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element</span>) &#123; <span class="hljs-comment">/* 添加元素到Queue，类似于Array.prototype.push */</span> &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取头元素*/</span> &#125;<br>  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 弹出头元素，类似于Array.prototype.pop */</span> &#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* 获取元素数量 */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注意</em></p><p>请只使用Stack，不要使用Array。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* you can use this Class which is bundled together with your code</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">class Stack &#123;</span><br><span class="hljs-comment">  push(element) &#123; // add element to stack &#125;</span><br><span class="hljs-comment">  peek() &#123; // get the top element &#125;</span><br><span class="hljs-comment">  pop() &#123; // remove the top element&#125;</span><br><span class="hljs-comment">  size() &#123; // count of element &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/* Array is disabled in your code */</span><br><br><span class="hljs-comment">// you need to complete the following Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element</span>) &#123; <br>    <span class="hljs-comment">// add new element to the rare</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(element);<br>  &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-comment">// get the head element</span><br>    <span class="hljs-keyword">let</span> rStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>);<br>    <span class="hljs-keyword">let</span> result = rStack.<span class="hljs-title function_">peek</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(rStack);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-comment">// return count of element</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">size</span>();<br>  &#125;<br>  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// remove the head element</span><br>    <span class="hljs-keyword">let</span> rStack = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>);<br>    <span class="hljs-keyword">let</span> result = rStack.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_reverse</span>(rStack);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-title function_">_reverse</span>(<span class="hljs-params">stack</span>) &#123;<br>    <span class="hljs-keyword">let</span> rStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-keyword">while</span>(stack.<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>      rStack.<span class="hljs-title function_">push</span>(stack.<span class="hljs-title function_">pop</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> rStack;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 记得复习一下函数，对象，类的写法</span><br></code></pre></td></tr></table></figure><hr><h1 id="14-实现memo"><a href="#14-实现memo" class="headerlink" title="14. 实现memo()"></a>14. 实现<code>memo()</code></h1><p><a href="https://whatthefuck.is/memoization">Memoization</a> 是应用广泛的性能优化的手段，如果你开发过React应用，你一定不会对<code>React.memo</code>感到陌生。</p><p>Memoization在算法题目中也经常用到，如果你可以用递归解决某个问题，那么很多时候加上Memoization可以得到更好的解法，甚至最终引导到动态规划的解法。</p><p>那么，请实现你自己的<code>memo()</code> 函数。传入相同的参数的时候，直接返回上一次的结果而不经过计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> arg1 + arg2<br>&#125;<br><br><span class="hljs-keyword">const</span> memoed = <span class="hljs-title function_">memo</span>(func)<br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3， func 被调用</span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3，func 未被调用 </span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 4，新参数，func 被调用</span><br></code></pre></td></tr></table></figure><p>参数有可能不是字符串，所以你的<code>memo()</code>需要能接受第三个决定缓存key的参数，有点类似于<a href="https://lodash.com/docs/4.17.15#memoize">_.memoize()</a> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> memoed = <span class="hljs-title function_">memo</span>(func, <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;samekey&#x27;</span>)<br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3，func被调用，缓存key是 &#x27;samekey&#x27;</span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <br><span class="hljs-comment">// 3，因为key是一样的，3被直接返回，func未调用</span><br><br><span class="hljs-title function_">memoed</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <br><span class="hljs-comment">// 3，因为key是一样的，3被直接返回，func未调用</span><br></code></pre></td></tr></table></figure><p>默认的key可以用<code>Array.from(arguments).join(&#39;_&#39;)</code>。</p><p><em>注意</em></p><p>这是一种空间换时间的优化，在实际面试中，请仔细分析时间空间复杂度。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">(args:[]) =&gt; string </span>&#125;  [resolver] - cache key generator</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">memo</span>(<span class="hljs-params">func, resolver</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">memoried</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">typeof</span> resolver === <span class="hljs-string">&#x27;function&#x27;</span> ? resolver.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args) : args.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;_&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(cache.<span class="hljs-title function_">has</span>(key)) &#123;<br>      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> result = func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      cache.<span class="hljs-title function_">set</span>(key, result);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="15-实现类似jQuery的DOM-wrapper"><a href="#15-实现类似jQuery的DOM-wrapper" class="headerlink" title="15. 实现类似jQuery的DOM wrapper"></a>15. 实现类似jQuery的DOM wrapper</h1><p>如果你使用过jQuery，你一定不会对下面的代码感到陌生。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#button&#x27;</span>)<br>  .<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;#fff&#x27;</span>)<br>  .<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;backgroundColor&#x27;</span>, <span class="hljs-string">&#x27;#000&#x27;</span>)<br>  .<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;fontWeight&#x27;</span>, <span class="hljs-string">&#x27;bold&#x27;</span>)<br></code></pre></td></tr></table></figure><p>以上的代码把几处更改链接在一起，更改了按钮的背景色和文字颜色。</p><p>链式操作的使用，让代码更具可读性。</p><p>为了让上述代码可用，请实现自己的<code>$()</code>，只需要支持<code>css(propertyName: string, value: any)</code>即可。</p><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">HTMLElement</span>&#125; <span class="hljs-variable">el</span> - element to be wrapped</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">$</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">css</span>(<span class="hljs-params">prop, value</span>) &#123;<br>      el.<span class="hljs-property">style</span>[prop] = value;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 对象中的this 指的是自己，函数对象中的this 指的是调用函数的对象</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(二)</title>
    <link href="/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%BA%8C)/"/>
    <url>/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="4-手写throttle"><a href="#4-手写throttle" class="headerlink" title="4. 手写throttle()"></a>4. 手写throttle()</h1><p>Throttle是web应用中经常用到的技巧，通常情况下你应该使用现有的实现，比如<a href="https://lodash.com/docs/4.17.15#throttle">lodash throttle()</a> 。</p><p>你能够自己实现一个基本的<code>throttle()</code>吗？</p><p>再次说明一下，<code>throttle(func, delay)</code>返回一个function，这个function无论多么频繁地调用，原始的func的调用也不会超过指定的频率。</p><p>比如，这是throttle之前的调用</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─ E─ ─F─G</p><p>按照3个单位进行throttle过后</p><p>─A─ ─ ─C─ ─ ─D ─ ─ ─ ─ E─ ─ ─G</p><p>注意到</p><ul><li>A因为不在任何的冷却时间，所以立即被执行</li><li>B被跳过了，因为B和C都在A的冷却时间里。</li></ul><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.throttle()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttled</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!timerId) &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(lastArgs) &#123;<br>          func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs); <br>          <span class="hljs-built_in">clearTimeout</span>(timerId);<br>        &#125;<br>      &#125;, wait)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lastArgs = args;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// throttle 节流阀，节流，也就是说在一定时间内，只执行一次，冷却时间过后, 再执行下一次事件，在冷却时间内的调用，会被推到定时器时间结束</span><br></code></pre></td></tr></table></figure><hr><h1 id="5-手写throttle-并支持leading-和-trailing"><a href="#5-手写throttle-并支持leading-和-trailing" class="headerlink" title="5. 手写throttle()并支持leading 和 trailing"></a>5. 手写throttle()并支持leading 和 trailing</h1><p>该题目是<a href="https://bigfrontend.dev/zh/problem/implement-basic-throttle">4. 手写throttle()</a>的后续，请先完成第4题。</p><p>本题目中你需要实现一个增强的<code>throttle()</code>，使其支持第三个参数<code>option: &#123;leading: boolean, trailing: boolean&#125;</code></p><ol><li>leading: 是否立即执行</li><li>trailing: 是否在冷却后执行</li></ol><p><a href="https://bigfrontend.dev/zh/problem/implement-basic-throttle()">4. 手写throttle()</a> 实际上是 <code>&#123;leading: true, trailing: true&#125;</code>的特殊情形。</p><p><strong>具体说明</strong></p><p>同样地按照之前的3单位的throttle来举例。</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─ E─ ─F─G</p><p>用<code>&#123;leading: true, trailing: true&#125;</code>来throttle后，我们得到</p><p>─A─ ─ ─C─ ─ ─D ─ ─ ─ ─ E─ ─ ─G</p><p>如果是 <code>&#123;leading: false, trailing: true&#125;</code>，A 和 E 被跳过了</p><p>─ ─ ─ ─C─ ─ ─D─ ─ ─ ─ ─ ─ ─G</p><p>如果是 <code>&#123;leading: true, trailing: false&#125;</code>，只有 A D E 被保留</p><p>─A─ ─ ─ ─D─ ─ ─ ─ ─ ─ E</p><p>如果是 <code>&#123;leading: false, trailing: false&#125;</code>，显而易见，什么都不会发生</p><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.throttle()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.leading</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.trailing</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait, option = &#123;leading: <span class="hljs-literal">true</span>, trailing: <span class="hljs-literal">true</span>&#125;</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttled</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">waitFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">trailing</span> &amp;&amp; lastArgs) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>        lastArgs = <span class="hljs-literal">null</span>;<br>        timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        timerId = <span class="hljs-literal">null</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!timerId) &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">leading</span>) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125;<br>      timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lastArgs = args;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 难度还是挺大的，最关键的是要明白，在冷却时间后，要不要再设置定时器</span><br><span class="hljs-comment">// 根据题目要求，根据lastyargs 和trailing 参数，决定是否设置定时器</span><br></code></pre></td></tr></table></figure><hr><h1 id="6-手写debounce"><a href="#6-手写debounce" class="headerlink" title="6. 手写debounce()"></a>6. 手写debounce()</h1><p><strong>Debounce是web应用中经常用到的技巧，通常情况下你应该使用现有的实现，比如<a href="https://lodash.com/docs/4.17.15#debounce">lodash debounce()</a> 。</strong></p><p>你能够自己实现一个基本的<code>debounce()</code>吗？</p><p>比如，在debounce之前如下的调用</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─E─ ─F─G</p><p>经过3单位的debounce之后变为了</p><p>─ ─ ─ ─ ─ ─ ─ ─ D ─ ─ ─ ─ ─ ─ ─ ─ ─ G</p><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.debounce()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">debouced</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">waitFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(!lastArgs) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>        lastArgs = <span class="hljs-literal">null</span>;<br>      &#125;<br>      timerId = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(timerId) &#123;<br>      lastArgs = args;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125;<br>    timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 防抖也是一段时间后，再执行函数，不过冷却时间内有新的事件，那么定时器时间则重新开始计算</span><br></code></pre></td></tr></table></figure><hr><h1 id="7-手写debounce-并支持leading-和-trailing"><a href="#7-手写debounce-并支持leading-和-trailing" class="headerlink" title="7. 手写debounce()并支持leading 和 trailing"></a>7. 手写debounce()并支持leading 和 trailing</h1><p>该题目是<a href="https://bigfrontend.dev/zh/problem/implement-basic-debounce">6. 手写debounce()</a>的延续，请先完成第6题。</p><p>本题目中你需要实现一个增强的<code>debounce()</code>，使其支持第三个参数<code>option: &#123;leading: boolean, trailing: boolean&#125;</code></p><ol><li>leading: 是否立即执行</li><li>trailing: 是否在冷却后执行</li></ol><p><a href="https://bigfrontend.dev/zh/problem/implement-basic-debounce">6. 手写debounce()</a> 实际上是 <code>&#123;leading: false, trailing: true&#125;</code>的特殊情形。</p><p><strong>具体说明</strong></p><p>还是之前的3单位的例子来说明。</p><p>─A─B─C─ ─D─ ─ ─ ─ ─ ─ E─ ─F─G</p><p>用<code>&#123;leading: false, trailing: true&#125;</code>来debounce过后，我们得到：</p><p>─ ─ ─ ─ ─ ─ ─ ─D─ ─ ─ ─ ─ ─ ─ ─ ─ G</p><p>如果是<code>&#123;leading: true, trailing: true&#125;</code>的话：</p><p>─A─ ─ ─ ─ ─ ─ ─D─ ─ ─E─ ─ ─ ─ ─ ─G</p><p>如果是<code>&#123;leading: true, trailing: false&#125;</code>：</p><p>─A─ ─ ─ ─ ─ ─ ─ ─ ─ ─E</p><p>如果是 <code>&#123;leading: false, trailing: false&#125;</code>，当然，什么都不会发生。</p><p><strong>注意</strong></p><ol><li>请按照以上spec完成代码。以上逻辑和<code>lodash.debounce()</code>并不完全一致</li><li>因为 <code>window.setTimeout</code> 和 <code>window.clearTimeout</code> 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface是一样的。</li></ol><p>大概会按照以下的样子进行代码测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>  currentTime = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> calls = []<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg</span>) =&gt; &#123;<br>     calls.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;arg&#125;</span>@<span class="hljs-subst">$&#123;currentTime&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> throttled = <span class="hljs-title function_">throttle</span>(func, <span class="hljs-number">3</span>)<br>  input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">call</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> [arg, time] = call.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;@&#x27;</span>)<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">throttled</span>(arg), time)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> calls<br>&#125;<br><br><span class="hljs-title function_">expect</span>(<span class="hljs-title function_">run</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;B@2&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])).<span class="hljs-title function_">toEqual</span>([<span class="hljs-string">&#x27;A@0&#x27;</span>, <span class="hljs-string">&#x27;C@3&#x27;</span>])<br></code></pre></td></tr></table></figure><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">wait</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.leading</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; option.trailing</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait, option = &#123;leading: <span class="hljs-literal">false</span>, trailing: <span class="hljs-literal">true</span>&#125;</span>) &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-keyword">let</span> timerId, lastArgs;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">debouced</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">waitFunc</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">trailing</span>) &#123;<br>        <span class="hljs-keyword">if</span>(lastArgs) &#123;<br>          func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, lastArgs);<br>          lastArgs = <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;<br>      timerId = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(timerId) &#123;<br>      lastArgs = args;<br>      <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span>(option.<span class="hljs-property">leading</span>) &#123;<br>        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        lastArgs = args; <span class="hljs-comment">// 陷阱：option.leading 为false, 的时候，冷却时间到了，开头的事件也是要执行的 </span><br>      &#125;<br>    &#125;<br>    timerId = <span class="hljs-built_in">setTimeout</span>(waitFunc, wait);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bigfrontend 代码题(一)</title>
    <link href="/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%B8%80)/"/>
    <url>/blog/2021/10/19/bigfrontend%20%E4%BB%A3%E7%A0%81%E9%A2%98(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-实现curry"><a href="#1-实现curry" class="headerlink" title="1. 实现curry()"></a>1. 实现curry()</h1><p><a href="https://en.wikipedia.org/wiki/Currying">柯里化(Currying)</a> 在JavaScript是一个常用的技巧。</p><p>请实现一个<code>curry()</code>方法，接受一个function然后返回一个柯里化过后的function。</p><p>这是一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">join</span> = (<span class="hljs-params">a, b, c</span>) =&gt; &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span>_<span class="hljs-subst">$&#123;b&#125;</span>_<span class="hljs-subst">$&#123;c&#125;</span>`</span><br>&#125;<br><br><span class="hljs-keyword">const</span> curriedJoin = <span class="hljs-title function_">curry</span>(join)<br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br></code></pre></td></tr></table></figure><p>阅读更多</p><p><a href="https://javascript.info/currying-partials">https://javascript.info/currying-partials</a></p><p><a href="https://lodash.com/docs/4.17.15#curry">https://lodash.com/docs/4.17.15#curry</a></p><hr><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) &#123;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= func.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>) &#123;<br>        <span class="hljs-keyword">return</span> curried.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(args2));<br>      &#125;<br>    &#125;<br>  &#125;;<br><br>&#125;<br><span class="hljs-comment">// func.length 指的是函数定义的参数长度</span><br><span class="hljs-comment">// bind，apply，call三者都可以改变函数的this对象指向。</span><br><span class="hljs-comment">// 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。</span><br><span class="hljs-comment">// 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。</span><br><span class="hljs-comment">// bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/82340026">bind，apply，call三者的区别</a></p><hr><h1 id="2-实现支持placeholder的curry"><a href="#2-实现支持placeholder的curry" class="headerlink" title="2. 实现支持placeholder的curry()"></a>2. 实现支持placeholder的curry()</h1><p>该问题紧接着<a href="https://bigfrontend.dev/zh/problem/implement-curry">1. 实现curry()</a>。</p><p>请实现一个支持placeholder的<code>curry()</code>，可以像这样使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span>  <span class="hljs-title function_">join</span> = (<span class="hljs-params">a, b, c</span>) =&gt; &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span>_<span class="hljs-subst">$&#123;b&#125;</span>_<span class="hljs-subst">$&#123;c&#125;</span>`</span><br>&#125;<br><br><span class="hljs-keyword">const</span> curriedJoin = <span class="hljs-title function_">curry</span>(join)<br><span class="hljs-keyword">const</span> _ = curry.<span class="hljs-property">placeholder</span><br><br><span class="hljs-title function_">curriedJoin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(_, <span class="hljs-number">2</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br><br><span class="hljs-title function_">curriedJoin</span>(_, _, _)(<span class="hljs-number">1</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>) <span class="hljs-comment">// &#x27;1_2_3&#x27;</span><br></code></pre></td></tr></table></figure><p>阅读更多</p><p><a href="https://javascript.info/currying-partials">https://javascript.info/currying-partials</a></p><p><a href="https://lodash.com/docs/4.17.15#curry">https://lodash.com/docs/4.17.15#curry</a></p><p><a href="https://github.com/planttheidea/curriable">https://github.com/planttheidea/curriable</a></p><hr><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Function </span>&#125; <span class="hljs-variable">func</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> complete = args.<span class="hljs-property">length</span> &gt;= func.<span class="hljs-property">length</span> &amp;&amp; !args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, func.<span class="hljs-property">length</span>).<span class="hljs-title function_">includes</span>(curry.<span class="hljs-property">placeholder</span>);<br>    <span class="hljs-keyword">if</span>(complete) <span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>) &#123;<br>      <span class="hljs-comment">// replace placeholders in args with values from newArgs</span><br>      <span class="hljs-keyword">const</span> res = args.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg === curry.<span class="hljs-property">placeholder</span> &amp;&amp; newArgs.<span class="hljs-property">length</span> ? newArgs.<span class="hljs-title function_">shift</span>() : arg);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">curried</span>(...res, ...newArgs);<br>    &#125;<br>  &#125;<br>&#125;<br><br>curry.<span class="hljs-property">placeholder</span> = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-comment">// 很巧妙，用了一个递归的思想</span><br></code></pre></td></tr></table></figure><hr><h1 id="3-实现Array-prototype-flat"><a href="#3-实现Array-prototype-flat" class="headerlink" title="3. 实现Array.prototype.flat()"></a>3. 实现Array.prototype.flat()</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">Array.prototype.flat()</a>可以用来扁平化数组。</p><p>你能够自己实现一个flat么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>]]];<br><br><span class="hljs-title function_">flat</span>(arr)<br><span class="hljs-comment">// [1, 2, 3, [4]]</span><br><br><span class="hljs-title function_">flat</span>(arr, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// [1, 2, 3, [4]]</span><br><br><span class="hljs-title function_">flat</span>(arr, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p><strong>追问</strong></p><p>能否不用递归而用迭代的方式实现？</p><hr><p>ans:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 递归版本</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array </span>&#125; <span class="hljs-variable">arr</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> number </span>&#125; <span class="hljs-variable">depth</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type"> Array </span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr, depth = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-comment">// your imeplementation here</span><br>  <span class="hljs-keyword">let</span> result = []<br>  <span class="hljs-keyword">if</span>(depth &gt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        result = result.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flat</span>(item, depth-<span class="hljs-number">1</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        result.<span class="hljs-title function_">push</span>(item)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 迭代版本</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr, depth = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-comment">// [[1,1] [[2],1], [[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[[2],1], [[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[2,0], [[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[[3, [4]],1]]</span><br>  <span class="hljs-comment">// [[3, 0], [[4], 0]]</span><br>  <br>  <span class="hljs-keyword">const</span> result = []<br>  <span class="hljs-keyword">const</span> stack = [...arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ([item, depth]))]<br>  <br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> [top, depth] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(top) &amp;&amp; depth &gt; <span class="hljs-number">0</span>) &#123;<br>      stack.<span class="hljs-title function_">push</span>(...top.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ([item, depth - <span class="hljs-number">1</span>])))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(top)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">reverse</span>()<br>&#125;<br><span class="hljs-comment">// 这个迭代版本就是把元素一个一个剥开一层都推入stack 中，符合条件的，推入结果数组</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>做题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过命令行使用Python</title>
    <link href="/blog/2021/10/18/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8Python/"/>
    <url>/blog/2021/10/18/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8Python/</url>
    
    <content type="html"><![CDATA[<p>from: <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#">命令行与环境</a></p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>调用 Python 时，可以指定下列任意选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python [-bBdEhiIOqsSuvVWx?] [-c <span class="hljs-built_in">command</span> | -m module-name | script | - ] [args]<br></code></pre></td></tr></table></figure><p>最常见的用例是启动时执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python myscript.py<br></code></pre></td></tr></table></figure><blockquote><p>通过运行 <code>where python</code> 可以查看 <code>python</code> 安装位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\HP&gt;<span class="hljs-built_in">where</span> python<br>C:\Python27\python.exe<br>C:\Program Files\python\python.exe<br>C:\Users\HP\AppData\Local\Microsoft\WindowsApps\python.exe<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\HP&gt;<span class="hljs-built_in">where</span> py<br>C:\Windows\py.exe<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\HP&gt;<span class="hljs-built_in">where</span> python3<br>C:\Users\HP\AppData\Local\Microsoft\WindowsApps\python3.exe<br></code></pre></td></tr></table></figure><p>不知不觉安装了这么多<code>python</code>！ 😂</p></blockquote><hr><h3 id="接口选项"><a href="#接口选项" class="headerlink" title="接口选项"></a>接口选项</h3><p>解释器接口类似于 UNIX shell，但提供了额外的调用方法:</p><ul><li>用连接到 tty 设备的标准输入调用时，会提示输入并执行命令，<strong>输入 EOF （文件结束符，UNIX 中按 Ctrl-D，Windows 中按 Ctrl-Z, Enter）时终止</strong>。✨✨</li><li>用文件名参数或以标准输入文件调用时，读取，并执行该脚本文件。</li><li>用目录名参数调用时，从该目录读取、执行适当名称的脚本。</li><li>用 <code>-c command</code> 调用时，执行 <em>command</em> 表示的 Python 语句。<em>command</em> 可以包含用换行符分隔的多条语句。注意，前导空白字符在 Python 语句中非常重要！✨✨</li><li>用 <code>-m module-name</code> 调用时，在 Python 模块路径中查找指定的模块，并将其作为脚本执行。✨✨</li></ul><p>非交互模式下，先解析全部输入，再执行。</p><p>接口选项会终结解释器读入的选项列表，所有后续参数都在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.argv"><code>sys.argv</code></a> 里 – 注意，首个元素，即下标为零的元素（<code>sys.argv[0]</code>）是表示程序来源的字符串</p><h3 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-?<br>-h<br>--<span class="hljs-built_in">help</span><br><span class="hljs-comment"># 输出所有命令行选项的简介。</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-V<br>--version<br><span class="hljs-comment"># 输出 Python 版本号并退出</span><br></code></pre></td></tr></table></figure><p>。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Python 3.8.0b2+<br></code></pre></td></tr></table></figure><p>输入两次 <code>V</code> 选项时，输出更多构建信息，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Python 3.8.0b2+ (3.8:0c076caaa8, Apr 20 2019, 21:55:00)<br>[GCC 6.2.0 20161005]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>文档阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript中变量、函数、对象、类的声明方法汇总</title>
    <link href="/blog/2021/09/21/Javascript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/blog/2021/09/21/Javascript%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zh.javascript.info/variables">变量</a></p><blockquote><p>关注变量的声明符，<code>let</code>、<code>const</code>、<code>var</code> <a href="https://zh.javascript.info/var">旧时的 “var”</a></p><ul><li><code>let</code> — 现代的变量声明方式。</li><li><code>var</code> — 老旧的变量声明方式。一般情况下，我们不会再使用它。但是，我们会在 <a href="https://zh.javascript.info/var">旧时的 “var”</a> 章节介绍 <code>var</code> 和 <code>let</code> 的微妙差别，以防你需要它们。</li><li><code>const</code> — 类似于 <code>let</code>，但是变量的值无法被修改。</li></ul><p>变量的命名：</p><ul><li><p>变量名称必须仅包含字母，数字，符号 <code>$</code> 和 <code>_</code>。</p></li><li><p>首字符必须非数字。</p></li></ul><p>变量的连续声明用逗号分隔</p></blockquote><p><a href="https://zh.javascript.info/function-basics">函数</a></p><blockquote><p>声明方式，function <functionName>([parameters]) { /* code */}</p><ul><li>作为参数传递给函数的值，会被复制到函数的局部变量。</li><li>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。</li><li>函数可以返回值。如果没有返回值，则其返回的结果是 <code>undefined</code></li></ul><p>函数命名：</p><ul><li>函数名应该清楚地描述函数的功能。当我们在代码中看到一个函数调用时，一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。</li><li>一个函数是一个行为，所以函数名通常是动词。</li><li>目前有许多优秀的函数名前缀，如 <code>create…</code>、<code>show…</code>、<code>get…</code>、<code>check…</code> 等等。使用它们来提示函数的作用吧。</li></ul></blockquote><p><a href="https://zh.javascript.info/object">对象</a></p><blockquote><p>可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// “构造函数” 的语法</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;  <span class="hljs-comment">// “字面量” 的语法</span><br></code></pre></td></tr></table></figure><p>属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。</p><p>其他类型会被自动地转换为字符串，<strong>值可以是任何类型</strong>。</p><p>可以用下面的方法访问属性：</p><ul><li>点符号: <code>obj.property</code>。</li><li>方括号 <code>obj[&quot;property&quot;]</code>，方括号允许从变量中获取键，例如 <code>obj[varWithKey]</code>。</li></ul><p>其他操作：</p><ul><li>删除属性：<code>delete obj.prop</code>。</li><li>**检查是否存在给定键的属性：<code>&quot;key&quot; in obj</code>**。</li><li><strong>遍历对象：<code>for(let key in obj)</code> 循环</strong>。</li></ul><p>JavaScript 中还有很多其他类型的对象：</p><ul><li><code>Array</code> 用于存储有序数据集合，</li><li><code>Date</code> 用于存储时间日期，</li><li><code>Error</code> 用于存储错误信息。</li><li>……等等。</li></ul><p>它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实<strong>它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展</strong>。</p></blockquote><p><a href="https://zh.javascript.info/function-object">函数对象</a></p><blockquote><ul><li><code>name</code> —— 函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。</li><li><code>length</code> —— 函数定义时的入参的个数。Rest 参数不参与计数。</li></ul><p>如果函数是<strong>通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字，那么它被称为命名函数表达式（Named Function Expression）</strong>。这个名字可以用于在该函数内部进行自调用，例如递归调用等。</p></blockquote><p><a href="https://zh.javascript.info/prototype-inheritance">函数原型</a></p><blockquote><p><a href="https://zh.javascript.info/prototype-inheritance#zong-jie">总结</a></p><ul><li>在 JavaScript 中，所有的对象都有一个隐藏的 <code>[[Prototype]]</code> 属性，它要么是另一个对象，要么就是 <code>null</code>。</li><li>我们可以使用 <code>obj.__proto__</code> 访问它（历史遗留下来的 getter/setter，这儿还有其他方法，很快我们就会讲到）。</li><li>通过 <code>[[Prototype]]</code> 引用的对象被称为“原型”。</li><li>如果我们想要读取 <code>obj</code> 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li><li>写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</li><li>如果我们调用 <code>obj.method()</code>，而且 <code>method</code> 是从原型中获取的，<code>this</code> 仍然会引用 <code>obj</code>。因此，方法始终与当前对象一起使用，即使方法是继承的。</li><li><code>for..in</code> 循环在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。</li></ul></blockquote><p><a href="https://zh.javascript.info/class">类</a></p><blockquote><p>基本的类语法看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  prop = value; <span class="hljs-comment">// 属性</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...</span>) &#123; <span class="hljs-comment">// 构造器</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-title function_">method</span>(<span class="hljs-params">...</span>) &#123;&#125; <span class="hljs-comment">// method</span><br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">...</span>) &#123;&#125; <span class="hljs-comment">// getter 方法</span><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">something</span>(<span class="hljs-params">...</span>) &#123;&#125; <span class="hljs-comment">// setter 方法</span><br><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;&#125; <span class="hljs-comment">// 有计算名称（computed name）的方法（此处为 symbol）</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>技术上来说，<code>MyClass</code> 是一个函数（我们提供作为 <code>constructor</code> 的那个），而 methods、getters 和 settors 都被写入了 <code>MyClass.prototype</code>。</p></blockquote><p>总结一下：</p><blockquote><p><strong>JavaScript 中，一切都是对象</strong>。在一个函数对象中，可以声明基础变量，叫做静态属性，属于这个对象。</p><p>this.[props] 声明的是对象实例化后的公有属性，可以用来进行方法操作。</p><p>方法，又有好几种声明方法，函数式声明，函数表达式声明，对象键值对式的声明。</p><ul><li><p>键值对式的声明，一般用在对象中，作为属性存在；</p></li><li><p>函数声明，用在类中，作为对象原型中的方法存在，在函数对象中，做为私有方法存在；</p></li><li><p>函数表达式，有this，则公有，否，私有的。</p></li></ul></blockquote><p>See see: <a href="https://github.com/Wscats/articles/issues/85">前端程序员经常忽视的一个JavaScript面试题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>知识汇总</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的apply、call、bind 方法的区别</title>
    <link href="/blog/2021/09/02/%E5%87%BD%E6%95%B0%E7%9A%84apply%E3%80%81call%E3%80%81bind-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/blog/2021/09/02/%E5%87%BD%E6%95%B0%E7%9A%84apply%E3%80%81call%E3%80%81bind-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://zh.javascript.info/call-apply-decorators">装饰器模式和转发，call/apply</a></p><p><strong>装饰器</strong> 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。</p><p>装饰器可以被看作是可以添加到函数的 “features” 或 “aspects”。我们可以添加一个或添加多个。而这一切都无需更改其代码！</p><p>为了实现 <code>cachingDecorator</code>，我们研究了以下方法：</p><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/call">func.call(context, arg1, arg2…)</a> —— 用给定的上下文和参数调用 <code>func</code>。也就是说，<strong>将传进来的context 对象作为函数的调用对象</strong>；</li><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">func.apply(context, args)</a> —— 调用 <code>func</code> 将 <code>context</code> 作为 <code>this</code> 和类数组的 <code>args</code> 传递给参数列表。</li></ul><p>通用的 <strong>呼叫转移（call forwarding）</strong> 通常是使用 <code>apply</code> 完成的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wrapper = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们也可以看到一个 <strong>方法借用（method borrowing）</strong> 的例子，就是我们从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它。采用数组方法并将它们应用于参数 <code>arguments</code> 是很常见的。另一种方法是使用 Rest 参数对象，该对象是一个真正的数组。</p><hr><p>call:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">(method) <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">call</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">thisArg</span>: any, ...<span class="hljs-attr">argArray</span>: any[]): any<br><br><span class="hljs-title class_">Calls</span> a method <span class="hljs-keyword">of</span> an object, substituting another object <span class="hljs-keyword">for</span> the current object. <span class="hljs-comment">// 引用一个对象的方法，把那个对象替换为当前对象（传进来的那个）</span><br><br>@param thisArg — <span class="hljs-title class_">The</span> object to be used <span class="hljs-keyword">as</span> the current object.<br><br>@param argArray — A list <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span> to be passed to the method.<br></code></pre></td></tr></table></figure><p>apply:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">(method) <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">thisArg</span>: any, argArray?: any): any<br><span class="hljs-title class_">Calls</span> the <span class="hljs-keyword">function</span>, substituting the specified object <span class="hljs-keyword">for</span> the <span class="hljs-variable language_">this</span> value <span class="hljs-keyword">of</span> the <span class="hljs-keyword">function</span>, and the specified array <span class="hljs-keyword">for</span> the <span class="hljs-variable language_">arguments</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">function</span>. <span class="hljs-comment">// 引用函数值，替换函数的this 为指定的对象。指定数组作为函数的参数</span><br><br>@param thisArg — <span class="hljs-title class_">The</span> object to be used <span class="hljs-keyword">as</span> the <span class="hljs-variable language_">this</span> object.<br><br>@param argArray — A set <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span> to be passed to the <span class="hljs-keyword">function</span>.<br></code></pre></td></tr></table></figure><p>bind:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">(method) <span class="hljs-title class_">Function</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">thisArg</span>: any, ...<span class="hljs-attr">argArray</span>: any[]): any<br><span class="hljs-title class_">For</span> a given <span class="hljs-keyword">function</span>, creates a bound <span class="hljs-keyword">function</span> that has the same body <span class="hljs-keyword">as</span> the original <span class="hljs-keyword">function</span>. <span class="hljs-title class_">The</span> <span class="hljs-variable language_">this</span> object <span class="hljs-keyword">of</span> the bound <span class="hljs-keyword">function</span> is associated <span class="hljs-keyword">with</span> the specified object, and has the specified initial parameters. <span class="hljs-comment">// 对于被给定的函数，创建一个和原始函数有相同主体的绑定了的函数，这个绑定了的函数和指定的对象相关联，有着明确的初始化参数。</span><br><br>@paramthisArg — <span class="hljs-title class_">An</span> object to which the <span class="hljs-variable language_">this</span> keyword can refer inside the <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>.<br><br>@paramargArray — A list <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span> to be passed to the <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>知识总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的*和&amp;</title>
    <link href="/blog/2021/08/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/"/>
    <url>/blog/2021/08/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="What’s-the-difference-between-and-amp-in-C"><a href="#What’s-the-difference-between-and-amp-in-C" class="headerlink" title="What’s the difference between * and &amp; in C?"></a><a href="https://stackoverflow.com/questions/28778625/whats-the-difference-between-and-in-c">What’s the difference between * and &amp; in C?</a></h1><p><code>*</code> 和 <code>&amp;</code> 作为<strong>类型修饰符</strong>：</p><ul><li><p><code>int i</code> 声明一个整数类型变量 <code>i</code></p></li><li><p><code>int* p</code> 声明一个指向整数类型变量的指针 <code>p</code></p></li><li><p><code>int&amp; r = i</code> 声明一个对整数类型变量的引用，并且这个变量为 <code>i</code>. （仅用在C++ 中，注意引用必须在初始化的时候进行赋值；因此 <code>int&amp; i;</code> 是不存在的）</p><p>类似的就有：</p></li><li><p><code>void foo(int i)</code> 声明一个函数，以整数类型变量为参数（作为一个副本，按值传递）</p></li><li><p><code>void foo(int* p)</code> 声明一个函数，以一个指向整数类型变量的指针（整型指针）为参数</p></li><li><p><code>void foo(int&amp; r)</code> 声明一个函数，以整数类型变量的引用为参数（仅用在C++ 中）</p></li></ul><hr><p><code>*</code> 和 <code>&amp;</code> 作为<strong>操作符</strong>：</p><ul><li><p><code>foo(i)</code> 调用 <code>foo(int)</code>. 参数通过值的副本传递</p></li><li><p><code>foo(*p)</code> 去掉指针变量 <code>p</code> 的引用，用被 <code>p</code> 指向的整数作为参数去调用 <code>foo(int)</code> </p></li><li><p><code>foo(&amp;i)</code> 以整数类型变量 <code>i</code> 的地址为参数，用变量的地址为参数调用 <code>foo(int*)</code> （意思就是说，你要一个变量引用，我就声明一个整型指针给你）</p><hr></li></ul><p>（tl;dr）太长不看版本，简而言之，符号的作用取决于上下文环境：</p><ul><li><code>*</code> 既可以作为 去掉指针引用的操作符，也可以作为指针声明符的一部分；</li><li><code>&amp;</code> 可以作为取地址操作符，在C++ 中还可以作为引用声明符的一部分；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术学习方法总结</title>
    <link href="/blog/2021/08/01/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/08/01/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>我主张，在具备基础之后，学习任何新东西，都要抓住主线，突出重点。对于关键理论的学习，要集中精力，速战速决。而旁枝末节和非本质性的知识内容，完全可以留给实践去零敲碎打。</p><p>原因是这样的，任何一个高级的知识内容，其中都只有一小部分是有思想创新、有重大影响的，而其它很多东西都是琐碎的、非本质的。因此，集中学习时必须把握住真正重要那部分，把其它东西留给实践。对于重点知识，只有集中学习其理论，才能确保体系性、连贯性、正确性，而对于那些旁枝末节，只有边干边学能够让你了解它们的真实价值是大是小，才能让你留下更生动的印象。如果你把精力用错了地方，比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧，而对于真正重要的、思想性东西放在平时零敲碎打，那么肯定是事倍功半，甚至适得其反。</p><p>因此我对于市面上绝大部分开发类图书都不满——它们基本上都是面向知识体系本身的，而不是面向读者的。总是把相关的所有知识细节都放在一堆，然后一堆一堆攒起来变成一本书。反映在内容上，就是毫无重点地平铺直叙，不分轻重地陈述细节，往往在第三章以前就用无聊的细节谋杀了读者的热情。为什么当年侯捷先生的《深入浅出MFC》和 Scott Meyers 的 Effective C++ 能够成为经典？就在于这两本书抓住了各自领域中的主干，提纲挈领，纲举目张，一下子打通读者的任督二脉。可惜这样的书太少，就算是已故 Richard Stevens 和当今 Jeffrey Richter 的书，也只是在体系性和深入性上高人一头，并不是面向读者的书。</p><p>最近我闲逛各技术社区，最深的一个感受，就是开发者的niubility value也跟中国社会的 income distribution 一样，呈现严重的两极分化状态。所以我建议那些老鸟们，多做一点提纲挈领的总结工作，把真正紧要的东西总结出来，给社区一些贡献。<br>————————————————<br>版权声明：本文为CSDN博主「myan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/myan/article/details/5877305">https://blog.csdn.net/myan/article/details/5877305</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程语言学习方法</title>
    <link href="/blog/2021/07/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/07/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>现在的开发工作要求我们能够快速掌握一门语言。一般来说应对这种挑战有两种态度：其一，粗粗看看语法，就撸起袖子开干，边查Google边学习；其二是花很多时间完整地把整个语言学习一遍，做到胸有成竹，然后再开始做实际工作。然而这两种方法都有弊病。第二种方法的问题当然很明显，不仅浪费了时间，偏离了目标，而且学习效率不高。因为没有实际问题驱动的语言学习通常是不牢固不深入的。有的人学着学着成了语言专家，反而忘了自己原本是要解决问题来的。第一种路子也有问题，在对于这种语言的脾气秉性还没有了解的情况下大刀阔斧地拼凑代码，写出来的东西肯定不入流。说穿新鞋走老路，新瓶装旧酒，那都是小问题，真正严重的是这样的程序员可以在短时间内堆积大量充满缺陷的垃圾代码。由于通常开发阶段的测试完备程度有限，这些垃圾代码往往能通过这个阶段，从而潜伏下来，在后期成为整个项目的毒瘤，反反复复让后来的维护者陷入西西弗斯困境。</p><p>实际上语言学习有一定规律可循，对于已经掌握一门语言的开发者来说，对于一般的语言，完全可以以最快的速度，在几天至一周之内掌握其最常用的50%，而且保证路子基本正宗，没有出偏的弊病。其实真正写程序不怕完全不会，最怕一知半解的去攒解决方案。因为你完全不会，就自然会去认真查书学习，如果学习能力好的话，写出来的代码质量不会差。而一知半解，自己动手土法炼钢，那搞出来的基本上都是废铜烂铁。比如错误处理和序列化，很多人不去了解“正路子”，而是凭借自己的一知半解去攒野路子，这是最危险的。因此，即使时间再紧张，这些内容也是必须首先完整了解一遍的。掌握这些内容之后进入实际开发，即使有问题，也基本不会伤及项目大体。而开发者本人则可以安步当车，慢慢在实践中提高自己。</p><p>以下列出一个学习提纲，主要针对的是有经验的人，初学者不合适。这个提纲只能用于一般的庸俗编程语言学习，目前在流行编程语言排行榜上排前20的基本上都是庸俗语言。如果你要学的是LISP之类非庸俗语言，或是某个软件中的二次开发语言，这里的建议未必合适。还是那句话，仅供参考。</p><ol><li><p>首先<strong><font color="#0000ff">了解该语言的基本数据类型，基本语法和主要语言构造</font></strong>，主要数学运算符和print函数的使用，达到能够写谭浩强程序设计书课后数学习题的程度；</p></li><li><p>其次<strong><font color="#0000ff">其次掌握数组和其他集合类的使用</font></strong>，有基础的话可以理解一下泛型，如果理解不了也问题不大，后面可以补；</p></li><li><p>简单字符串处理。所谓简单，就是Regex和Parser以下的内容，什么查找替换，截断去字串之类的。不过这个阶段有一个难点，就是字符编码问题。如果理解不了，可以先跳过，否则的话最好在这时候把这个问题搞定，免留后患；</p></li><li><p><strong><font color="#0000ff">基本面向对象或者函数式编程的特征</font></strong>，无非是什么继承、多态、Lambda函数之类的，如果有经验的话很快就明白了；</p></li><li><p><strong><font color="#0000ff">异常、错误处理、断言、日志和调试支持，对单元测试的支持</font></strong>。你不一定要用TDD，但是在这个时候应该掌握在这个语言里做TDD的基本技能；</p></li><li><p><strong><font color="#0000ff">程序代码和可执行代码的组织机制，运行时模块加载、符号查找机制</font></strong>，这是初学时的一个难点，因为大部分书都不太注意介绍这个极为重要的内容；</p></li><li><p><strong><font color="#0000ff">基本输入输出和文件处理，输入输出流类的组织</font></strong>，这通常是比较繁琐的一部分，可以提纲挈领学一下，搞清楚概念，用到的时候查就是了。到这个阶段可以写大部分控制台应用了；</p></li><li><p><strong><font color="#0000ff">该语言如何进行callback方法调用，如何支持事件驱动编程模型。</font></strong>。在现代编程环境下，这个问题是涉及开发思想的一个核心问题，几乎每种语言在这里都会用足功夫，.NET的delegate，Java的anonymous inner class，Java 7的closure，C++OX的 tr1::function/bind，五花八门。如果能彻底理解这个问题，不但程序就不至于写得太走样，而且对该语言的设计思路也能有比较好的认识；</p></li><li><p>如果有必要，可在这时研究regex和XML处理问题，如无必要可跳过；</p></li><li><p><strong><font color="#0000ff">序列化和反序列化</font></strong>，掌握一下缺省的机制就可以了；</p></li><li><p>如果必要，可了解一下线程、并发和异步调用机制，主要是为了读懂别人的代码，如果自己要写这类代码，必须专门花时间严肃认真系统地学习，严禁半桶水上阵；</p></li><li><p>动态编程，反射和元数据编程，数据和程序之间的相互转化机制，运行时编译和执行的机制，有抱负的开发者在这块可以多下些功夫，能够使你对语言的认识高出一个层面；</p></li><li><p>如果有必要，可研究一下该语言对于泛型的支持，不必花太多时间，只要能使用现成的泛型集合和泛型函数就可以了，可在以后闲暇时抽时间系统学习。需要注意的是，泛型技术跟多线程技术一样，用不好就成为万恶之源，必须系统学习，谨慎使用，否则不如不学不用；</p></li><li><p>如果还有时间，最好咨询一下有经验的人，看看这个语言较常用的特色features是什么，如果之前没学过，应当补一下。比如Ruby的block interator, Java的dynamic proxy，C# 3的LINQ和extension method。没时间的话，我认为也可以边做边学，没有大问题。</p></li><li><p>有必要的话，在工作的闲暇时间，可以着重考察两个问题，第一，这个语言有哪些惯用法和模式，第二，这个语言的编译/解释执行机制。</p></li></ol><p>至此语言的基本部分就可以说掌握了，之后是做数据库、网络还是做图形，可以根据具体需求去搞，找相应的成熟框架或库，边做边学，加深理解。对于一个庸俗语言，我自己把上面的内容走一遍大概要花2-3周时间，不能算很快，但也耽误不了太多事情，毕竟不是每个月都学新语言。掌握了以上的内容，就给练武术打好了基本功，虽然不见得有多优秀，但是肯定是根正苗红，将来不必绕大弯子。就算是临时使用的语言，把上面这个提纲精简一下，只看蓝色重体字的部分，大致能在几天到一周内搞定，不算是太耗时，而且写出来的代码不会太不靠谱。</p><p>以上提纲未设及内存模型。对于C/C++，这个问题很重要，要放在显著位置来考虑，但对于其他语言，这个问题被透明化了，除非你要做hardcore项目，否则不必太关注。<br>————————————————<br>版权声明：本文为CSDN博主「myan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/myan/article/details/3144661">https://blog.csdn.net/myan/article/details/3144661</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语学习方法</title>
    <link href="/blog/2021/07/18/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/07/18/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p> 来源：<a href="https://zhuanlan.zhihu.com/p/24665519">学好英文的十个步骤</a></p><p>之前我们已经看到了，学会英文可以帮你节约至少600块钱（最多可以到7300人民币）。如此巨大的收益，让人们不禁要问：我如何才能学会英文呢？</p><p>学会英文很简单；你学会了汉语自然就表明你有能力学会英文。下面我们就来列出大纲描绘一下学习英文的几个基本阶段：</p><p>注意：虽然是大纲性质，也是21分钟就能看完的，但这篇文章是不收钱的。原因很简单，因为大部分人就算看懂了以下步骤，英文也是学不会的。从效果来说，就好像学会了C++你也找不到工作，这样怎么能收费呢？逃。。。）</p><p><strong>前置条件：</strong></p><p>你的英文词汇量已经达到高三人教版教材要求的水平，也就是掌握英文常用单词数目2000个。如果你还没达到，建议你退学重读高一。我有很多高中可以推荐，例如郴州市明星学校。需要的可以私信我。</p><p>这2000个单词，我分为如下几个部分：</p><ol><li><p>1000个名词；重要生活物件的名词，表述思维的抽象名词等。apple，orange 当然是需要的；inspiration, sabotage 也是需要的。</p></li><li><p>250个动词；描述任意动作和抽象动作。do，make是需要的；reinforce, heighten 更是需要的。</p></li><li><p>250个副词；修辞动作。happily， luckily 当然是需要的；figuratively, ubiquitously 也是需要的；</p></li><li><p>500个形容词；修辞名词。big，large当然是需要的；blunt, riveting 更是需要的。</p></li></ol><p><strong>步骤一：</strong></p><p>学会基本的语法。我建议买一本【薄冰英语语法】来看。千万不要听高中老师胡说八道。</p><p>下面是几个例子：</p><ol><li><p>理解为什么 there is a woman swallowing banana 里面的swallowing 必须是ing形式；</p></li><li><p>理解为什么 Do you know where he heads 里面的 heads 后面为什么不加 to；</p></li><li><p>理解为什么 Given time, we would heal 里面的 given 为什么不是 giving；</p></li><li><p>理解为什么 Why you always take things for granted 里面的 granted 要用被动。</p></li></ol><p><strong>步骤二：</strong></p><p>买一本英英词典（例如牛津词典），并且把你的汉英、英汉词典烧掉；该辞典的好处是用2000个常用字解释所有词条。每次看见新单词请打开这本辞典找到词条，用你的语法知识和单词量理解这个词。</p><p><strong>步骤三：</strong></p><p>使用学会的单词；看到一个学会的新单词，例如unanimously，你觉得太罕见不会用；不是的，请看他在词典中的例句，把例句背下来。</p><p><strong>步骤四：</strong></p><p>参加校园英语角，在英语角里面疯狂使用辞典例句，并且虚构故事，吓死他们。。逃）</p><p><strong>步骤五：</strong></p><p>上一个步骤是虚构的；在现实生活中，充分使用学习到的例句；例如早上起来了你要说什么？交作业忘记写了你要说什么？食堂打饭你要说什么？洗澡你要说什么？OOXX你要说什么？就这个意思。</p><p><strong>步骤六：</strong></p><p>用英文的逻辑改造你的思维。基于步骤五，你已经可以完全使用英文进行思考了。语言决定了你的思维能力；在思考的过程中，你会进一步具象化英文中的名词，动词，词组等；并且连接你听说读写之功能。因为说白了，听说读写的核心其实是让你用英文想。如果你都必须用中文想，说一口标准的大白东北英语，那你还是放弃治疗吧。</p><p><strong>步骤七：</strong></p><p>准备一个记录本，把你认为有用的动词，副词，形容词和名词按照这样的顺序（动副形名的顺序，因为他们在语言中的重要性依次递减）记录下来；方便日后参照。使用任何一种记忆法防止你忘记（一般来说忘记3次之后你就不会忘记了）。除非你过目不忘，这种形式还是很重要的。</p><p><strong>步骤八：</strong></p><p>买一本适合自己词汇量的英文杂志，例如空中英语教室。另外找一本新概念英语或者本科英语教材每天早上按照要求背诵一下。其实这都不重要，关键是把你字典上学会的东西找个地方用起来。</p><p><strong>步骤九：</strong></p><p>买一本Economist自己看，或者看Friends的英文原版英文字幕。尝试用英文开始写总结。其实这都不重要。对于程序员来说，能看懂就可以了，不需要写==</p><p><strong>步骤十：</strong></p><p>坚持1年。学完一年之后，相信你就可以自己去看C++ PRIMER了。另外，你不会还不知道PRIMER啥意思把。去看牛津词典，然后找那个例句自己练习100次。。</p><hr><p>曾老师的方法，核心在于 <strong>学以致用</strong>。</p><p>多数人在学习英语的过程中，一个常见的误区就是陷入单词和语法的细节地狱，这也可以看作是一个巨大的舒适区。当遇到问题时，不会从实践角度出发，理解问题，反而一头扎进单词语法的海洋中去了。我听不懂英语听力，那肯定是我词汇量不够；我看不懂英文文章，那肯定是我词汇量不够；我不会表达，那肯定是我词汇量不够；我写不出地道的英文文章，那肯定是我词汇量不够。彷佛一切都可以归结到词汇量不够这个问题上来了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>方法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《计算机系统要素》一书中的名人名言</title>
    <link href="/blog/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E4%B8%80%E4%B9%A6%E4%B8%AD%E7%9A%84%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/"/>
    <url>/blog/2021/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%E4%B8%80%E4%B9%A6%E4%B8%AD%E7%9A%84%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>What I hear, I forget; What I see, I remember; What I do, I understand.</p><p>耳听为虚，眼见为实；实践出真知。</p><p>—— 孔子</p><hr><p>The true voyage of discovery consists not of going to new places, but of having a new pair of eyes.</p><p>真正的发现之旅，不在于去一个新的地方，而在于拥有一双新的眼睛。</p><p>—— Marcel Proust</p><hr><p>Some simple things, And we make of them something so complex it defeats us, Almost.</p><p>一些简单的事情，我们往往把他搞得跟很复杂以至于几乎使我们失败。</p><p>—— John Ashbery</p><hr><p>Counting is the religion of this generation, its hope and salvation.</p><p>计算是这一代的信仰，希望，救赎。</p><p>—— Gertrude Stein</p><hr><p>It’s a poor sort of memory that only works backward.</p><p>记忆如此悲怜，只能回溯过去。</p><p>—— lewis Carroll</p><hr><p>Make everything as simple as possible, but not simpler.</p><p>让每件事尽可能简单，而又不简单过度。</p><p>—— 阿尔伯特 · 爱因斯坦</p><hr><p>Form ever follows function.</p><p>形式永远追随功能。</p><p>—— Louis Sullivan</p><hr><p>What’s in a name? That which we call a rose by any other name would smell as sweet.</p><p>名称有什么关系呢，玫瑰不叫玫瑰，依然芳香如故。</p><p>—— 莎士比亚</p><hr><p>Programmes are creators of universes for which they alone are responsible. Universes of virtually unlimited complexity can be created in the form of computer programs.</p><p>程序员对他们所创造的宇宙全权负责，因他们是这些宇宙的创造者。以计算机程序的形式，可以创造出几乎无限复杂的宇宙。</p><p>—— Joseph Weizenbaum</p><hr><p>If everything seems under control, you’re just not going fast enough.</p><p><strong>若一切看上去还都在掌控之中，那就说明你跑得还不够快。</strong></p><p>—— Mario Andretti</p><hr><p>High thoughs need a high language.</p><p>职高的思想需要至高的语言。</p><p>—— Aristophanes</p><hr><p>Neither can embellishments of language be found without arrangement and expression of thoughts, nor can thoughts be made to shine without the light of language.</p><p>既未组织思想，又未表达思想，语言便暗淡无光；没有语言之光照耀，思想便无法闪光。</p><p>—— Cicero</p><hr><p>The syntactic component of a grammar must specify, for each sentence, a deep structure that determines its semantic interpretation.</p><p>语法规范的语法成分必须为每个句子指定具有确定语义解释的深层结构。</p><p>—— Noam Chomesky</p><hr><p>Civilization progresses by extending the number of operations that we can perform without thinking about them.</p><p>对于不用经过特意思考就能执行的操作，其数量的增长推动文明进步。</p><p>—— Alfred North Whitehead</p><hr><p>We shall not cease from exploration, and at the end we will arrive where we started, and know the place for first time.</p><p>永远不应该停止探索的脚步，知道最后，再次抵达起点，我们才刚开始了解脚下的路。</p><p>—— T. S. Eliot</p><hr><p>Intelligence is the faculty of making artifical objects, expecially tools to make tools.</p><p>智能即知道人造物， 特别是制造制造工具的能力。</p><p>—— Henry Bergson</p>]]></content>
    
    
    
    <tags>
      
      <tag>摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSDoc 简要介绍</title>
    <link href="/blog/2021/07/04/JSDoc/"/>
    <url>/blog/2021/07/04/JSDoc/</url>
    
    <content type="html"><![CDATA[<h3 id="JSDoc"><a href="#JSDoc" class="headerlink" title="JSDoc"></a><a href="https://en.wikipedia.org/wiki/JSDoc">JSDoc</a></h3><p>JSDoc 是一种用来注释 JavaScript 源代码的标记语言。使用包含 JSDoc 的注释，程序员可以创建描述程序接口的文档。这种注释，可以被各种工具处理，生成类似 HTML 和 富文本格式的文档。JSDoc 规范基于  <a href="https://en.wikipedia.org/wiki/CC_BY-SA_3.0">CC BY-SA 3.0</a> 协议发布，与之对应的文档生成器和解析库是基于 <a href="https://en.wikipedia.org/wiki/Apache_License_2.0">Apache License 2.0</a> 发布的免费软件。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>JSDoc 的语法和语义类似于 javadoc 。JSDoc 与之不同之处在于，它专门用于处理 Javascript 的动态行为。</p><p>一个早期的例子，在 Netscape/Mozilla 的 Rhino 项目中，使用类似于 javadoc 语法的 js 文档发布在 1999 年。这是一个用 Java 写的 Javascript 运行系统，它包含一个玩具级的 HTML 生成器，版本更迭到 1.3，它也是 js 功能的一个例子。</p><p>所有主要版本的 JSDoc 都由 Michael Mathews 领导。在 2001 年，他与加拿大程序员 Gabriel Reid 合作，开始 JSDoc.pm 项目，这是一个用 Perl 写的简易系统。系统被托管在 SourceForge 上一个 CVS 仓库中。到 JSDoc 1.0 时，他用 Javascript 重写了系统，在一系列的拓展后，JSDoc 2.0 获得了一个 jsdoc-toolkit 的名字。基于 <a href="https://en.wikipedia.org/wiki/MIT_License">MIT License</a> 发布，被托管在 Google Code 的 Subversion仓库中。到 2011 年，他重构了系统到 JSDoc 3.0 版本，系统被托管在 Github 上。现如今运行在 Node.js 上。</p><h3 id="JSDoc-标签"><a href="#JSDoc-标签" class="headerlink" title="JSDoc 标签"></a>JSDoc 标签</h3><p>在现代的 JSDoc 中，常用的注释标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>@author</code></td><td align="center">开发者名字</td></tr><tr><td align="center"><code>@constructor</code></td><td align="center">把函数标记为构造器</td></tr><tr><td align="center"><code>@deprecated</code></td><td align="center">标记函数被弃用</td></tr><tr><td align="center"><code>@exception</code></td><td align="center"><code>@throws</code> 的同义词</td></tr><tr><td align="center"><code>@exports</code></td><td align="center">识别一个被导出成一个模块的成员</td></tr><tr><td align="center"><code>@param</code></td><td align="center">记录一个函数的参数，数据类型可以放在花括号中被添加进来</td></tr><tr><td align="center"><code>@private</code></td><td align="center">表示成员时私有的</td></tr><tr><td align="center"><code>@returns</code></td><td align="center">记录返回值</td></tr><tr><td align="center"><code>@return</code></td><td align="center"><code>@returns</code> 的同义词</td></tr><tr><td align="center"><code>@see</code></td><td align="center">记录到另一个对象的关联</td></tr><tr><td align="center"><code>@todo</code></td><td align="center">记录一些缺少的东西</td></tr><tr><td align="center"><code>@this</code></td><td align="center">明确在一个函数中， this 关键字所指的对象的类型</td></tr><tr><td align="center"><code>@throws</code></td><td align="center">记录方法所抛出的异常</td></tr><tr><td align="center"><code>@version</code></td><td align="center">提供库的版本</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** <span class="hljs-doctag">@class</span> Circle representing a circle. */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates an instance of Circle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: moi</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; r The desired radius of the circle.</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">r</span>) &#123;<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = r<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">circumference</span> = <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * r<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Creates a new Circle from a diameter.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; d The desired diameter of the circle.</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Circle</span>&#125; The new Circle object.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fromDiameter</span>(<span class="hljs-params">d</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(d / <span class="hljs-number">2</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Calculates the circumference of the Circle.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@deprecated</span> since 1.1.0; use getCircumference instead</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125; The circumference of the circle.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">calculateCircumference</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Returns the pre-computed circumference of the Circle.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125; The circumference of the circle.</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@since</span> 1.1.0</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">getCircumference</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">circumference</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Find a String representation of the Circle.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@override</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">Human</span>-readable representation of this Circle.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`[A Circle object with radius of <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.radius&#125;</span>.]`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Prints a circle.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Circle</span>&#125; <span class="hljs-variable">circle</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printCircle</span>(<span class="hljs-params">circle</span>) &#123;<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@this</span> &#123;<span class="hljs-type">Circle</span>&#125; */</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bound</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) &#125;<br>    bound.<span class="hljs-title function_">apply</span>(circle)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，@class 和 @constructor 标签事实上可以被省略。ECMA 语法足够清晰的表明它们，JSDoc 利用了这个。@overrride 也是可以被自动地推断出来的。</p><h3 id="使用中的-JSDoc"><a href="#使用中的-JSDoc" class="headerlink" title="使用中的 JSDoc"></a>使用中的 JSDoc</h3><ul><li>谷歌的闭源 Linter 和 编译器，后者抽取出类型信息来优化 Javascript 的输出</li><li>Typescript 可以对有 JSDoc 类型注释的 js 文件执行类型检查。微软已经指定了一种有着可拓展标签的 TSDoc 语言</li><li>一个很受欢迎的编辑器 Sublime Text 通过 DocBlocker 或者 DoxyDoxygen 插件支持 JSDoc</li><li>在 Apress 的书 Ajax 基础 中， JSDoc 语法具有相当的篇幅</li><li><a href="https://en.wikipedia.org/wiki/IntelliJ_IDEA">IntelliJ IDEA</a>, <a href="https://en.wikipedia.org/wiki/NetBeans">NetBeans</a>, <a href="https://en.wikipedia.org/wiki/Visual_Studio_Code">Visual Studio Code</a> 和 <a href="https://en.wikipedia.org/wiki/RubyMine">RubyMine</a> 支持 JSDoc 语法</li><li>基于 Eclipse <a href="https://en.wikipedia.org/wiki/Aptana_Studio">Aptana Studio</a> 支持 ScriptDoc</li><li><a href="http://mozile.mozdev.org/0.8/doc/jsdoc/index.html">Mozile</a>, the Mozilla Inline Editor 使用了 JSDoc.pm</li><li><a href="https://web.archive.org/web/20150420064930/http://dev.helma.org/">Helma</a> 应用框架使用了 JSDoc</li><li>SproutCore 是使用 JSDoc 生成的</li><li><a href="https://en.wikipedia.org/wiki/Visual_Studio">Visual Studio</a>, <a href="https://en.wikipedia.org/wiki/WebStorm">WebStorm</a> 和许多其他的 IDE、编辑器，提供基于 JSDoc 注释的代码补全和辅助</li><li> <a href="https://en.wikipedia.org/wiki/Atom_(text_editor)">Atom</a> 通过 <a href="https://github.com/tgandrews/atom-easy-jsdoc">atom-easy-jsdoc</a> 插件支持 JSDoc</li></ul><h3 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h3><ul><li><a href="https://en.wikipedia.org/wiki/Comparison_of_documentation_generators">文档生成器的对比</a></li><li><a href="https://en.wikipedia.org/wiki/Google_Closure_Tools">谷歌内部工具</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>翻译 Wiki</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web cache 简要介绍</title>
    <link href="/blog/2021/06/27/Web-cache/"/>
    <url>/blog/2021/06/27/Web-cache/</url>
    
    <content type="html"><![CDATA[<h3 id="Web-cache"><a href="#Web-cache" class="headerlink" title="Web cache"></a><a href="https://zh.wikipedia.org/wiki/Web%E7%BC%93%E5%AD%98">Web cache</a></h3><p>网络缓存，或者说 HTTP 缓存，是用来优化互联网的系统。在应用端和服务器端都有实现。图片或者其他文件的缓存，可以使得在浏览网页的时候，时延更小。</p><h4 id="系统的部分介绍"><a href="#系统的部分介绍" class="headerlink" title="系统的部分介绍"></a>系统的部分介绍</h4><h5 id="正向与反向缓存"><a href="#正向与反向缓存" class="headerlink" title="正向与反向缓存"></a>正向与反向缓存</h5><p>正向缓存是一个在 web 服务器之外，但是在客户端浏览器、ISP 或者公司网络之内的缓存。正向缓存只缓存被大量获取的内容。一个在客户端和服务器之间的代理服务器可以通过 HTTP 请求头来选择是否要存储 web 内容。</p><p>反向缓存位在于一个或者多个 web 服务器前面，用来加速来自网络的请求，和缩减请求峰值的压力。通常表现为一个内容分发系统，在整个网络中保存各点的内容副本。</p><h5 id="HTTP-选项"><a href="#HTTP-选项" class="headerlink" title="HTTP 选项"></a>HTTP 选项</h5><p>超文本传输协议定义了用于控制缓存的三种基本机制：freshness, validation, and invalidation。这在来自服务器的 HTTP 响应消息的中被指定。</p><p>Freshness 允许不在原始服务器上重新检查它而使用响应 ，并且可以由服务器和客户端控制。 例如，到期响应给出了文档过期的日期，并且 Cache-Control: max-age 指令告诉缓存响应可用的秒数。</p><p>Validation 可用于检查缓存的响应过期后是否仍然良好的缓存响应。 例如，如果响应具有 Last-Modified 的 header，则缓存可以使用 If-Modified-Since header 来进行条件请求，以查看它是否已更改。 Etag（实体标签）机制也允许强和弱验证。</p><p>Invalidation 通常是通过缓存传递的另一个请求的副作用。 例如，如果与缓存响应关联的URL随后获取发布，放置或删除请求，则缓存响应将无效。 许多 CDN 和网络设备制造商都用动态缓存替换了这个标准的HTTP缓存控制。</p><h5 id="合法性"><a href="#合法性" class="headerlink" title="合法性"></a>合法性</h5><p>1998年，DMCA为美国法典（17U.S.C.§：512）增加了规则，以便为缓存而豁免系统运营商的版权责任</p><h5 id="服务器端软件"><a href="#服务器端软件" class="headerlink" title="服务器端软件"></a>服务器端软件</h5><p>这是服务器端网络缓存软件列表。</p><table><thead><tr><th align="center">名字</th><th align="center">操作系统</th><th align="center">Forward mode</th><th align="center">Reverse mode</th><th align="center">许可证书</th></tr></thead><tbody><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Apache_HTTP_Server_for_S60">Apache HTTP Server</a></td><td align="center">Windows, OS X, Linux, Unix, FreeBSD, Solaris, Novell NetWare, OS/2, TPF, OpenVMS and eComStation</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Apache_License_2.0">Apache License 2.0</a></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/AiScaler">aiScaler</a> Dynamic Cache Control</td><td align="center">Linux</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/ApplianSys#CACHEbox">ApplianSys CACHEbox</a></td><td align="center">Linux</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Blue_Coat_Systems">Blue Coat</a> ProxySG</td><td align="center">SGOS</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Nginx">Nginx</a></td><td align="center"><a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, <a href="https://en.wikipedia.org/wiki/BSD">BSD variants</a>, <a href="https://en.wikipedia.org/wiki/OS_X">OS X</a>, <a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris</a>, <a href="https://en.wikipedia.org/wiki/AIX">AIX</a>, <a href="https://en.wikipedia.org/wiki/HP-UX">HP-UX</a>, other <a href="https://en.wikipedia.org/wiki/*nix">*nix</a> flavors</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">2-clause <a href="https://en.wikipedia.org/wiki/BSD_licenses">BSD</a>-like</td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Microsoft_Forefront_Threat_Management_Gateway">Microsoft Forefront Threat Management Gateway</a></td><td align="center">Windows</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Polipo">Polipo</a></td><td align="center"><a href="https://en.wikipedia.org/wiki/Windows">Windows</a>, <a href="https://en.wikipedia.org/wiki/OS_X">OS X</a>, <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, <a href="https://en.wikipedia.org/wiki/OpenWrt">OpenWrt</a>, <a href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/MIT_License">MIT License</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Squid_(software)">Squid</a></td><td align="center">Linux, <a href="https://en.wikipedia.org/wiki/Unix_filesystem">Unix</a>, <a href="https://en.wikipedia.org/wiki/Windows_10_version_history">Windows</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU General Public License</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Traffic_Server">Traffic Server</a></td><td align="center">Linux, Unix</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Apache_License_2.0">Apache License 2.0</a></td></tr><tr><td align="center">Untangle</td><td align="center">Linux</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/Varnish_(software)">Varnish</a></td><td align="center">Linux, Unix</td><td align="center">Yes (possible with a VMOD)</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/BSD_licenses">BSD</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/WinGate">WinGate</a></td><td align="center">Windows</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a> / Free for 8 users</td></tr><tr><td align="center">Nuster</td><td align="center">Linux, Unix</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU General Public License</a></td></tr><tr><td align="center"><a href="https://en.wikipedia.org/wiki/McAfee">McAfee</a> Web Gateway</td><td align="center">McAfee Linux Operating System</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"><a href="https://en.wikipedia.org/wiki/Proprietary_software">Proprietary</a></td></tr></tbody></table><h5 id="进一步了解："><a href="#进一步了解：" class="headerlink" title="进一步了解："></a>进一步了解：</h5><ul><li><a href="https://en.wikipedia.org/wiki/Cache_manifest_in_HTML5">Cache manifest in HTML5</a></li><li><a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content delivery network</a></li><li><a href="https://en.wikipedia.org/wiki/Harvest_project">Harvest project</a></li><li><a href="https://en.wikipedia.org/wiki/Proxy_server">Proxy server</a></li><li><a href="https://en.wikipedia.org/wiki/Web_accelerator">Web accelerator</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>翻译 Wiki</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github Pages搭建博客</title>
    <link href="/blog/2021/06/21/use-github-pages-build-blog/"/>
    <url>/blog/2021/06/21/use-github-pages-build-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="Github-Pages-建站教程"><a href="#Github-Pages-建站教程" class="headerlink" title="Github Pages 建站教程"></a>Github Pages 建站教程</h2><p>电脑中已安装：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>在所需的应用程序安装完成后，即可使用 npm 安装 hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完 hexo 后，执行下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br><span class="hljs-built_in">cd</span> &lt;folder&gt;<br>npm install<br></code></pre></td></tr></table></figure><p>会生成下列所示的文件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.yml <span class="hljs-comment"># 修改网站的配置信息</span><br>├── package.json<br>├── scaffolds <span class="hljs-comment"># 存储模板文件，当您新建文章时，Hexo 会根据 scaffold 来建立文件</span><br>├── <span class="hljs-built_in">source</span><br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><h2 id="该写点啥了"><a href="#该写点啥了" class="headerlink" title="该写点啥了"></a>该写点啥了</h2><p>运行命令，生成要转为 html 文件的 md 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>eg. <code>hexo new &quot;post title with whitespace&quot;</code> 会生成默认布局的以 <code>post title with whitespace</code> 为标题的 md 文件。</p><p>运行命令，生成静态文件，即要渲染到 Github Pages 的网页文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate <br></code></pre></td></tr></table></figure><p>运行命令，启动服务器，查看效果。默认情况下，访问网址为： <code>http://localhost:4000/</code>。每次修改后，都要重新运行命令，查看更新效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><h2 id="最后一步，部署到-Github-Pages"><a href="#最后一步，部署到-Github-Pages" class="headerlink" title="最后一步，部署到 Github Pages"></a>最后一步，部署到 Github Pages</h2><p>首先安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>再修改 _config.yml 的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  <span class="hljs-comment"># repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br>  repo: git@github.com:Hercules11/Hercules11.github.io.git <span class="hljs-comment"># 走 ssh 通道, 不用输入用户名、密码</span><br>  branch: [branch] <span class="hljs-comment"># 页面文件所在分支</span><br></code></pre></td></tr></table></figure><h2 id="Hexo-部署的原理"><a href="#Hexo-部署的原理" class="headerlink" title="Hexo 部署的原理"></a>Hexo 部署的原理</h2><p>当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>参考： <a href="https://chuyang-fe.github.io/2021/03/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/">个人博客搭建指南</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>实战教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
